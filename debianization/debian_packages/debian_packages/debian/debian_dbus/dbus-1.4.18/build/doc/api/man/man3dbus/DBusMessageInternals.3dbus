.TH "DBusMessage implementation details" 3dbus "Wed Mar 26 2014" "Version 1.4.18" "D-Bus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DBusMessage implementation details \- 
.PP
\fBDBusMessage\fP private implementation details\&.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBDBusMessageLoader\fP"
.br
.RI "\fIImplementation details of \fBDBusMessageLoader\fP\&. \fP"
.ti -1c
.RI "struct \fBDBusMessage\fP"
.br
.RI "\fIInternals of \fBDBusMessage\fP\&. \fP"
.ti -1c
.RI "struct \fBDBusMessageRealIter\fP"
.br
.RI "\fIInternals of \fBDBusMessageIter\fP\&. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBCHANGED_STAMP_BITS\fP   21"
.br
.RI "\fIHow many bits are in the changed_stamp used to validate iterators\&. \fP"
.ti -1c
.RI "#define \fBensure_byte_order\fP(message)"
.br
.RI "\fIbyte-swap the message if it doesn't match our byte order\&. \fP"
.ti -1c
.RI "#define \fBMAX_MESSAGE_SIZE_TO_CACHE\fP   10 * _DBUS_ONE_KILOBYTE"
.br
.RI "\fIAvoid caching huge messages\&. \fP"
.ti -1c
.RI "#define \fBMAX_MESSAGE_CACHE_SIZE\fP   5"
.br
.RI "\fIAvoid caching too many messages\&. \fP"
.ti -1c
.RI "#define \fBINITIAL_LOADER_DATA_LEN\fP   32"
.br
.RI "\fIThe initial buffer size of the message loader\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct DBusInitialFDs \fBDBusInitialFDs\fP"
.br
.ti -1c
.RI "typedef struct \fBDBusMessageRealIter\fP \fBDBusMessageRealIter\fP"
.br
.RI "\fItypedef for internals of message iterator \fP"
.ti -1c
.RI "typedef struct \fBDBusMessageLoader\fP \fBDBusMessageLoader\fP"
.br
.RI "\fIThe \fBDBusMessageLoader\fP object encapsulates the process of converting a byte stream into a series of \fBDBusMessage\fP\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBDBUS_MESSAGE_ITER_TYPE_READER\fP =  3, \fBDBUS_MESSAGE_ITER_TYPE_WRITER\fP =  7 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_message_iter_get_args_valist\fP (\fBDBusMessageIter\fP *iter, \fBDBusError\fP *error, int first_arg_type, va_list var_args)"
.br
.RI "\fIImplementation of the varargs arg-getting functions\&. \fP"
.ti -1c
.RI "DBusInitialFDs * \fB_dbus_check_fdleaks_enter\fP (void)"
.br
.ti -1c
.RI "void \fB_dbus_check_fdleaks_leave\fP (DBusInitialFDs *fds)"
.br
.ti -1c
.RI "\fB_DBUS_STRING_DEFINE_STATIC\fP (_dbus_empty_signature_str,'')"
.br
.RI "\fIAn static string representing an empty signature\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_get_network_data\fP (\fBDBusMessage\fP *message, const \fBDBusString\fP **header, const \fBDBusString\fP **body)"
.br
.RI "\fIGets the data to be sent over the network for this message\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_get_unix_fds\fP (\fBDBusMessage\fP *message, const int **fds, unsigned *n_fds)"
.br
.RI "\fIGets the unix fds to be sent over the network for this message\&. \fP"
.ti -1c
.RI "void \fBdbus_message_set_serial\fP (\fBDBusMessage\fP *message, dbus_uint32_t serial)"
.br
.RI "\fISets the serial number of a message\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_add_counter_link\fP (\fBDBusMessage\fP *message, \fBDBusList\fP *link)"
.br
.RI "\fIAdds a counter to be incremented immediately with the size/unix fds of this message, and decremented by the size/unix fds of this message when this message if finalized\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_message_add_counter\fP (\fBDBusMessage\fP *message, \fBDBusCounter\fP *counter)"
.br
.RI "\fIAdds a counter to be incremented immediately with the size/unix fds of this message, and decremented by the size/unix fds of this message when this message if finalized\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_remove_counter\fP (\fBDBusMessage\fP *message, \fBDBusCounter\fP *counter, \fBDBusList\fP **link_return)"
.br
.RI "\fIRemoves a counter tracking the size/unix fds of this message, and decrements the counter by the size/unix fds of this message\&. \fP"
.ti -1c
.RI "void \fBdbus_message_lock\fP (\fBDBusMessage\fP *message)"
.br
.RI "\fILocks a message\&. \fP"
.ti -1c
.RI "\fBDBusMessageLoader\fP * \fB_dbus_message_loader_new\fP (void)"
.br
.RI "\fICreates a new message loader\&. \fP"
.ti -1c
.RI "\fBDBusMessageLoader\fP * \fB_dbus_message_loader_ref\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIIncrements the reference count of the loader\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_unref\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIDecrements the reference count of the loader and finalizes the loader when the count reaches zero\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_get_buffer\fP (\fBDBusMessageLoader\fP *loader, \fBDBusString\fP **buffer)"
.br
.RI "\fIGets the buffer to use for reading data from the network\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_return_buffer\fP (\fBDBusMessageLoader\fP *loader, \fBDBusString\fP *buffer, int bytes_read)"
.br
.RI "\fIReturns a buffer obtained from \fB_dbus_message_loader_get_buffer()\fP, indicating to the loader how many bytes of the buffer were filled in\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_message_loader_get_unix_fds\fP (\fBDBusMessageLoader\fP *loader, int **fds, unsigned *max_n_fds)"
.br
.RI "\fIGets the buffer to use for reading unix fds from the network\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_return_unix_fds\fP (\fBDBusMessageLoader\fP *loader, int *fds, unsigned n_fds)"
.br
.RI "\fIReturns a buffer obtained from \fB_dbus_message_loader_get_unix_fds()\fP\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_message_loader_queue_messages\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIConverts buffered data into messages, if we have enough data\&. \fP"
.ti -1c
.RI "\fBDBusMessage\fP * \fB_dbus_message_loader_peek_message\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIPeeks at first loaded message, returns \fBNULL\fP if no messages have been queued\&. \fP"
.ti -1c
.RI "\fBDBusMessage\fP * \fB_dbus_message_loader_pop_message\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIPops a loaded message (passing ownership of the message to the caller)\&. \fP"
.ti -1c
.RI "\fBDBusList\fP * \fB_dbus_message_loader_pop_message_link\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIPops a loaded message inside a list link (passing ownership of the message and link to the caller)\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_putback_message_link\fP (\fBDBusMessageLoader\fP *loader, \fBDBusList\fP *link)"
.br
.RI "\fIReturns a popped message link, used to undo a pop\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_message_loader_get_is_corrupted\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIChecks whether the loader is confused due to bad data\&. \fP"
.ti -1c
.RI "\fBDBusValidity\fP \fB_dbus_message_loader_get_corruption_reason\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIChecks what kind of bad data confused the loader\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_set_max_message_size\fP (\fBDBusMessageLoader\fP *loader, long size)"
.br
.RI "\fISets the maximum size message we allow\&. \fP"
.ti -1c
.RI "long \fB_dbus_message_loader_get_max_message_size\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIGets the maximum allowed message size in bytes\&. \fP"
.ti -1c
.RI "void \fB_dbus_message_loader_set_max_message_unix_fds\fP (\fBDBusMessageLoader\fP *loader, long n)"
.br
.RI "\fISets the maximum unix fds per message we allow\&. \fP"
.ti -1c
.RI "long \fB_dbus_message_loader_get_max_message_unix_fds\fP (\fBDBusMessageLoader\fP *loader)"
.br
.RI "\fIGets the maximum allowed number of unix fds per message\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fBdbus_message_allocate_data_slot\fP (dbus_int32_t *slot_p)"
.br
.RI "\fIAllocates an integer ID to be used for storing application-specific data on any \fBDBusMessage\fP\&. \fP"
.ti -1c
.RI "void \fBdbus_message_free_data_slot\fP (dbus_int32_t *slot_p)"
.br
.RI "\fIDeallocates a global ID for message data slots\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fBdbus_message_set_data\fP (\fBDBusMessage\fP *message, dbus_int32_t slot, void *data, \fBDBusFreeFunction\fP free_data_func)"
.br
.RI "\fIStores a pointer on a \fBDBusMessage\fP, along with an optional function to be used for freeing the data when the data is set again, or when the message is finalized\&. \fP"
.ti -1c
.RI "void * \fBdbus_message_get_data\fP (\fBDBusMessage\fP *message, dbus_int32_t slot)"
.br
.RI "\fIRetrieves data previously set with \fBdbus_message_set_data()\fP\&. \fP"
.ti -1c
.RI "int \fBdbus_message_type_from_string\fP (const char *type_str)"
.br
.RI "\fIUtility function to convert a machine-readable (not translated) string into a D-Bus message type\&. \fP"
.ti -1c
.RI "const char * \fBdbus_message_type_to_string\fP (int type)"
.br
.RI "\fIUtility function to convert a D-Bus message type into a machine-readable string (not translated)\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fBdbus_message_marshal\fP (\fBDBusMessage\fP *msg, char **marshalled_data_p, int *len_p)"
.br
.RI "\fITurn a \fBDBusMessage\fP into the marshalled form as described in the D-Bus specification\&. \fP"
.ti -1c
.RI "\fBDBusMessage\fP * \fBdbus_message_demarshal\fP (const char *str, int len, \fBDBusError\fP *error)"
.br
.RI "\fIDemarshal a D-Bus message from the format described in the D-Bus specification\&. \fP"
.ti -1c
.RI "int \fBdbus_message_demarshal_bytes_needed\fP (const char *buf, int len)"
.br
.RI "\fIReturns the number of bytes required to be in the buffer to demarshal a D-Bus message\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\fBDBusMessage\fP private implementation details\&. 

The guts of \fBDBusMessage\fP and its methods\&. 
.SH "Define Documentation"
.PP 
.SS "#define \fBensure_byte_order\fP(message)"\fBValue:\fP
.PP
.nf
if (message->byte_order != DBUS_COMPILER_BYTE_ORDER)   \
   _dbus_message_byteswap (message)
.fi
.PP
byte-swap the message if it doesn't match our byte order\&. Called only when we need the message in our own byte order, normally when reading arrays of integers or doubles\&. Otherwise should not be called since it would do needless work\&. 
.PP
Definition at line 142 of file dbus-message\&.c\&.
.SS "#define \fBINITIAL_LOADER_DATA_LEN\fP   32"
.PP
The initial buffer size of the message loader\&. \fBTodo\fP
.RS 4
this should be based on min header size plus some average body size, or something\&. Or rather, the min header size only, if we want to try to read only the header, store that in a \fBDBusMessage\fP, then read only the body and store that, etc\&., depends on how we optimize \fB_dbus_message_loader_get_buffer()\fP and what the exact message format is\&. 
.RE
.PP

.PP
Definition at line 3710 of file dbus-message\&.c\&.
.PP
Referenced by _dbus_message_loader_new()\&.
.SH "Typedef Documentation"
.PP 
.SS "\fBDBusMessageLoader\fP"
.PP
The \fBDBusMessageLoader\fP object encapsulates the process of converting a byte stream into a series of \fBDBusMessage\fP\&. It buffers the incoming bytes as efficiently as possible, and generates a queue of messages\&. \fBDBusMessageLoader\fP is typically used as part of a \fBDBusTransport\fP implementation\&. The \fBDBusTransport\fP then hands off the loaded messages to a \fBDBusConnection\fP, making the messages visible to the application\&.
.PP
\fBTodo\fP
.RS 4
write tests for break-loader that a) randomly delete header fields and b) set string fields to zero-length and other funky values\&.
.RE
.PP

.PP
Definition at line 33 of file dbus-message-internal\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBdbus_bool_t\fP \fB_dbus_message_add_counter\fP (\fBDBusMessage\fP *message, \fBDBusCounter\fP *counter)"
.PP
Adds a counter to be incremented immediately with the size/unix fds of this message, and decremented by the size/unix fds of this message when this message if finalized\&. \fBParameters:\fP
.RS 4
\fImessage\fP the message 
.br
\fIcounter\fP the counter 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if no memory 
.RE
.PP

.PP
Definition at line 268 of file dbus-message\&.c\&.
.PP
References _dbus_counter_ref(), _dbus_list_alloc_link(), _dbus_message_add_counter_link(), FALSE, NULL, and TRUE\&.
.PP
Referenced by _dbus_transport_queue_messages()\&.
.SS "void \fB_dbus_message_add_counter_link\fP (\fBDBusMessage\fP *message, \fBDBusList\fP *link)"
.PP
Adds a counter to be incremented immediately with the size/unix fds of this message, and decremented by the size/unix fds of this message when this message if finalized\&. The link contains a counter with its refcount already incremented, but the counter itself not incremented\&. Ownership of link and counter refcount is passed to the message\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message 
.br
\fIlink\fP link with counter as data 
.RE
.PP

.PP
Definition at line 224 of file dbus-message\&.c\&.
.PP
References _dbus_counter_adjust_size(), _dbus_counter_adjust_unix_fd(), _dbus_list_append_link(), DBusMessage::body, DBusMessage::counters, DBusList::data, DBusHeader::data, DBusMessage::header, NULL, and DBusMessage::size_counter_delta\&.
.PP
Referenced by _dbus_message_add_counter()\&.
.SS "void \fB_dbus_message_get_network_data\fP (\fBDBusMessage\fP *message, const \fBDBusString\fP **header, const \fBDBusString\fP **body)"
.PP
Gets the data to be sent over the network for this message\&. The header and then the body should be written out\&. This function is guaranteed to always return the same data once a message is locked (with \fBdbus_message_lock()\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message\&. 
.br
\fIheader\fP return location for message header data\&. 
.br
\fIbody\fP return location for message body data\&. 
.RE
.PP

.PP
Definition at line 157 of file dbus-message\&.c\&.
.PP
References DBusMessage::body, DBusHeader::data, DBusMessage::header, and DBusMessage::locked\&.
.SS "void \fB_dbus_message_get_unix_fds\fP (\fBDBusMessage\fP *message, const int **fds, unsigned *n_fds)"
.PP
Gets the unix fds to be sent over the network for this message\&. This function is guaranteed to always return the same data once a message is locked (with \fBdbus_message_lock()\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message\&. 
.br
\fIfds\fP return location of unix fd array 
.br
\fIn_fds\fP return number of entries in array 
.RE
.PP

.PP
Definition at line 176 of file dbus-message\&.c\&.
.PP
References DBusMessage::locked, and NULL\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_message_iter_get_args_valist\fP (\fBDBusMessageIter\fP *iter, \fBDBusError\fP *error, intfirst_arg_type, va_listvar_args)"
.PP
Implementation of the varargs arg-getting functions\&. \fBdbus_message_get_args()\fP is the place to go for complete documentation\&.
.PP
\fBTodo\fP
.RS 4
This may leak memory and file descriptors if parsing fails\&. See #21259
.RE
.PP
.PP
\fBSee also:\fP
.RS 4
\fBdbus_message_get_args\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the message iter 
.br
\fIerror\fP error to be filled in 
.br
\fIfirst_arg_type\fP type of the first argument 
.br
\fIvar_args\fP return location for first argument, followed by list of type/location pairs 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error was set 
.RE
.PP

.PP
Definition at line 722 of file dbus-message\&.c\&.
.PP
References _dbus_dup(), _dbus_strdup(), _dbus_type_reader_get_current_type(), _dbus_type_reader_get_element_type(), _dbus_type_reader_next(), _dbus_type_reader_read_basic(), _dbus_type_reader_read_fixed_multi(), _dbus_type_reader_recurse(), _dbus_type_to_string(), _dbus_warn(), DBUS_ERROR_INCONSISTENT_MESSAGE, DBUS_ERROR_INVALID_ARGS, DBUS_ERROR_NOT_SUPPORTED, dbus_free_string_array(), dbus_message_iter_get_arg_type(), dbus_new0, dbus_set_error(), DBUS_TYPE_ARRAY, DBUS_TYPE_INVALID, dbus_type_is_basic(), dbus_type_is_fixed(), DBUS_TYPE_OBJECT_PATH, DBUS_TYPE_SIGNATURE, DBUS_TYPE_STRING, DBUS_TYPE_UNIX_FD, FALSE, DBusMessageRealIter::message, NULL, DBusMessageRealIter::reader, TRUE, DBusMessageRealIter::u, and DBusBasicValue::u32\&.
.PP
Referenced by dbus_message_get_args_valist()\&.
.SS "void \fB_dbus_message_loader_get_buffer\fP (\fBDBusMessageLoader\fP *loader, \fBDBusString\fP **buffer)"
.PP
Gets the buffer to use for reading data from the network\&. Network data is read directly into an allocated buffer, which is then used in the \fBDBusMessage\fP, to avoid as many extra memcpy's as possible\&. The buffer must always be returned immediately using \fB_dbus_message_loader_return_buffer()\fP, even if no bytes are successfully read\&.
.PP
\fBTodo\fP
.RS 4
this function can be a lot more clever\&. For example it can probably always return a buffer size to read exactly the body of the next message, thus avoiding any memory wastage or reallocs\&.
.RE
.PP
.PP
\fBTodo\fP
.RS 4
we need to enforce a max length on strings in header fields\&.
.RE
.PP
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the message loader\&. 
.br
\fIbuffer\fP the buffer 
.RE
.PP

.PP
Definition at line 3818 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::buffer_outstanding, DBusMessageLoader::data, and TRUE\&.
.PP
Referenced by dbus_message_demarshal()\&.
.SS "\fBDBusValidity\fP \fB_dbus_message_loader_get_corruption_reason\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Checks what kind of bad data confused the loader\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.RE
.PP
\fBReturns:\fP
.RS 4
why the loader is hosed, or DBUS_VALID if it isn't\&. 
.RE
.PP

.PP
Definition at line 4292 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::corrupted, and DBusMessageLoader::corruption_reason\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_message_loader_get_is_corrupted\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Checks whether the loader is confused due to bad data\&. If messages are received that are invalid, the loader gets confused and gives up permanently\&. This state is called 'corrupted\&.'
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if the loader is hosed\&. 
.RE
.PP

.PP
Definition at line 4278 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::corrupted, and DBusMessageLoader::corruption_reason\&.
.PP
Referenced by _dbus_transport_queue_messages(), and dbus_message_demarshal()\&.
.SS "long \fB_dbus_message_loader_get_max_message_size\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Gets the maximum allowed message size in bytes\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.RE
.PP
\fBReturns:\fP
.RS 4
max size in bytes 
.RE
.PP

.PP
Definition at line 4326 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::max_message_size\&.
.PP
Referenced by _dbus_transport_get_max_message_size()\&.
.SS "long \fB_dbus_message_loader_get_max_message_unix_fds\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Gets the maximum allowed number of unix fds per message\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.RE
.PP
\fBReturns:\fP
.RS 4
max unix fds 
.RE
.PP

.PP
Definition at line 4357 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::max_message_unix_fds\&.
.PP
Referenced by _dbus_transport_get_max_message_unix_fds()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_message_loader_get_unix_fds\fP (\fBDBusMessageLoader\fP *loader, int **fds, unsigned *max_n_fds)"
.PP
Gets the buffer to use for reading unix fds from the network\&. This works similar to \fB_dbus_message_loader_get_buffer()\fP
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the message loader\&. 
.br
\fIfds\fP the array to read fds into 
.br
\fImax_n_fds\fP how many fds to read at most 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE on success, FALSE on OOM 
.RE
.PP

.PP
Definition at line 3860 of file dbus-message\&.c\&.
.PP
References dbus_realloc(), FALSE, DBusMessageLoader::max_message_unix_fds, and TRUE\&.
.SS "\fBDBusMessageLoader\fP* \fB_dbus_message_loader_new\fP (void)"
.PP
Creates a new message loader\&. Returns \fBNULL\fP if memory can't be allocated\&.
.PP
\fBReturns:\fP
.RS 4
new loader, or \fBNULL\fP\&. 
.RE
.PP

.PP
Definition at line 3719 of file dbus-message\&.c\&.
.PP
References _dbus_string_init(), _dbus_string_set_length(), DBusMessageLoader::corrupted, DBusMessageLoader::corruption_reason, DBusMessageLoader::data, dbus_free(), DBUS_MAXIMUM_MESSAGE_LENGTH, dbus_new0, FALSE, INITIAL_LOADER_DATA_LEN, DBusMessageLoader::max_message_size, DBusMessageLoader::max_message_unix_fds, NULL, and DBusMessageLoader::refcount\&.
.PP
Referenced by _dbus_transport_init_base(), and dbus_message_demarshal()\&.
.SS "\fBDBusMessage\fP* \fB_dbus_message_loader_peek_message\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Peeks at first loaded message, returns \fBNULL\fP if no messages have been queued\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the next message, or \fBNULL\fP if none\&. 
.RE
.PP

.PP
Definition at line 4219 of file dbus-message\&.c\&.
.PP
References DBusList::data, DBusMessageLoader::messages, and NULL\&.
.PP
Referenced by _dbus_transport_get_dispatch_status()\&.
.SS "\fBDBusMessage\fP* \fB_dbus_message_loader_pop_message\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Pops a loaded message (passing ownership of the message to the caller)\&. Returns \fBNULL\fP if no messages have been queued\&.
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the next message, or \fBNULL\fP if none\&. 
.RE
.PP

.PP
Definition at line 4236 of file dbus-message\&.c\&.
.PP
References _dbus_list_pop_first(), and DBusMessageLoader::messages\&.
.PP
Referenced by dbus_message_demarshal()\&.
.SS "\fBDBusList\fP* \fB_dbus_message_loader_pop_message_link\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Pops a loaded message inside a list link (passing ownership of the message and link to the caller)\&. Returns \fBNULL\fP if no messages have been loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the next message link, or \fBNULL\fP if none\&. 
.RE
.PP

.PP
Definition at line 4250 of file dbus-message\&.c\&.
.PP
References _dbus_list_pop_first_link(), and DBusMessageLoader::messages\&.
.PP
Referenced by _dbus_transport_queue_messages()\&.
.SS "void \fB_dbus_message_loader_putback_message_link\fP (\fBDBusMessageLoader\fP *loader, \fBDBusList\fP *link)"
.PP
Returns a popped message link, used to undo a pop\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.br
\fIlink\fP the link with a message in it 
.RE
.PP

.PP
Definition at line 4262 of file dbus-message\&.c\&.
.PP
References _dbus_list_prepend_link(), and DBusMessageLoader::messages\&.
.PP
Referenced by _dbus_transport_queue_messages()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_message_loader_queue_messages\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Converts buffered data into messages, if we have enough data\&. If we don't have enough data, does nothing\&.
.PP
\fBTodo\fP
.RS 4
we need to check that the proper named header fields exist for each message type\&.
.RE
.PP
.PP
\fBTodo\fP
.RS 4
If a message has unknown type, we should probably eat it right here rather than passing it out to applications\&. However it's not an error to see messages of unknown type\&.
.RE
.PP
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if we had enough memory to finish\&. 
.RE
.PP

.PP
Definition at line 4156 of file dbus-message\&.c\&.
.PP
References _dbus_header_have_message_untrusted(), _dbus_list_find_last(), DBusMessageLoader::corrupted, DBusMessageLoader::corruption_reason, DBusMessageLoader::data, dbus_message_unref(), DBUS_MINIMUM_HEADER_SIZE, FALSE, DBusMessageLoader::max_message_size, DBusMessageLoader::messages, NULL, and TRUE\&.
.PP
Referenced by _dbus_transport_get_dispatch_status(), and dbus_message_demarshal()\&.
.SS "\fBDBusMessageLoader\fP* \fB_dbus_message_loader_ref\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Increments the reference count of the loader\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the loader 
.RE
.PP

.PP
Definition at line 3767 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::refcount\&.
.SS "void \fB_dbus_message_loader_return_buffer\fP (\fBDBusMessageLoader\fP *loader, \fBDBusString\fP *buffer, intbytes_read)"
.PP
Returns a buffer obtained from \fB_dbus_message_loader_get_buffer()\fP, indicating to the loader how many bytes of the buffer were filled in\&. This function must always be called, even if no bytes were successfully read\&.
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.br
\fIbuffer\fP the buffer\&. 
.br
\fIbytes_read\fP number of bytes that were read into the buffer\&. 
.RE
.PP

.PP
Definition at line 3839 of file dbus-message\&.c\&.
.PP
References DBusMessageLoader::buffer_outstanding, DBusMessageLoader::data, and FALSE\&.
.PP
Referenced by dbus_message_demarshal()\&.
.SS "void \fB_dbus_message_loader_return_unix_fds\fP (\fBDBusMessageLoader\fP *loader, int *fds, unsignedn_fds)"
.PP
Returns a buffer obtained from \fB_dbus_message_loader_get_unix_fds()\fP\&. This works similar to \fB_dbus_message_loader_return_buffer()\fP
.PP
\fBParameters:\fP
.RS 4
\fIloader\fP the message loader\&. 
.br
\fIfds\fP the array fds were read into 
.br
\fImax_n_fds\fP how many fds were read 
.RE
.PP

.PP
Definition at line 3909 of file dbus-message\&.c\&.
.PP
References FALSE\&.
.SS "void \fB_dbus_message_loader_set_max_message_size\fP (\fBDBusMessageLoader\fP *loader, longsize)"
.PP
Sets the maximum size message we allow\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.br
\fIsize\fP the max message size in bytes 
.RE
.PP

.PP
Definition at line 4307 of file dbus-message\&.c\&.
.PP
References DBUS_MAXIMUM_MESSAGE_LENGTH, and DBusMessageLoader::max_message_size\&.
.PP
Referenced by _dbus_transport_set_max_message_size()\&.
.SS "void \fB_dbus_message_loader_set_max_message_unix_fds\fP (\fBDBusMessageLoader\fP *loader, longn)"
.PP
Sets the maximum unix fds per message we allow\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader 
.br
\fIsize\fP the max number of unix fds in a message 
.RE
.PP

.PP
Definition at line 4338 of file dbus-message\&.c\&.
.PP
References DBUS_MAXIMUM_MESSAGE_UNIX_FDS, and DBusMessageLoader::max_message_unix_fds\&.
.PP
Referenced by _dbus_transport_set_max_message_unix_fds()\&.
.SS "void \fB_dbus_message_loader_unref\fP (\fBDBusMessageLoader\fP *loader)"
.PP
Decrements the reference count of the loader and finalizes the loader when the count reaches zero\&. \fBParameters:\fP
.RS 4
\fIloader\fP the loader\&. 
.RE
.PP

.PP
Definition at line 3781 of file dbus-message\&.c\&.
.PP
References _dbus_list_clear(), _dbus_list_foreach(), _dbus_string_free(), DBusMessageLoader::data, dbus_free(), dbus_message_unref(), DBusMessageLoader::messages, NULL, and DBusMessageLoader::refcount\&.
.PP
Referenced by _dbus_transport_finalize_base(), _dbus_transport_init_base(), and dbus_message_demarshal()\&.
.SS "void \fB_dbus_message_remove_counter\fP (\fBDBusMessage\fP *message, \fBDBusCounter\fP *counter, \fBDBusList\fP **link_return)"
.PP
Removes a counter tracking the size/unix fds of this message, and decrements the counter by the size/unix fds of this message\&. \fBParameters:\fP
.RS 4
\fImessage\fP the message 
.br
\fIlink_return\fP return the link used 
.br
\fIcounter\fP the counter 
.RE
.PP

.PP
Definition at line 292 of file dbus-message\&.c\&.
.PP
References _dbus_counter_adjust_size(), _dbus_counter_adjust_unix_fd(), _dbus_counter_unref(), _dbus_list_find_last(), _dbus_list_free_link(), _dbus_list_unlink(), DBusMessage::counters, NULL, and DBusMessage::size_counter_delta\&.
.PP
Referenced by _dbus_connection_message_sent()\&.
.SS "\fBdbus_bool_t\fP \fBdbus_message_allocate_data_slot\fP (dbus_int32_t *slot_p)"
.PP
Allocates an integer ID to be used for storing application-specific data on any \fBDBusMessage\fP\&. The allocated ID may then be used with \fBdbus_message_set_data()\fP and \fBdbus_message_get_data()\fP\&. The passed-in slot must be initialized to -1, and is filled in with the slot ID\&. If the passed-in slot is not -1, it's assumed to be already allocated, and its refcount is incremented\&.
.PP
The allocated slot is global, i\&.e\&. all \fBDBusMessage\fP objects will have a slot with the given integer ID reserved\&.
.PP
\fBParameters:\fP
.RS 4
\fIslot_p\fP address of a global variable storing the slot 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP on failure (no memory) 
.RE
.PP

.PP
Definition at line 4380 of file dbus-message\&.c\&.
.PP
References _dbus_data_slot_allocator_alloc()\&.
.SS "\fBDBusMessage\fP* \fBdbus_message_demarshal\fP (const char *str, intlen, \fBDBusError\fP *error)"
.PP
Demarshal a D-Bus message from the format described in the D-Bus specification\&. Generally, this function is only useful for encapsulating D-Bus messages in a different protocol\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP the marshalled \fBDBusMessage\fP 
.br
\fIlen\fP the length of str 
.br
\fIerror\fP the location to save errors to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBNULL\fP if there was an error 
.RE
.PP

.PP
Definition at line 4604 of file dbus-message\&.c\&.
.PP
References _dbus_message_loader_get_buffer(), _dbus_message_loader_get_is_corrupted(), _dbus_message_loader_new(), _dbus_message_loader_pop_message(), _dbus_message_loader_queue_messages(), _dbus_message_loader_return_buffer(), _dbus_message_loader_unref(), _dbus_string_append_len(), DBusMessageLoader::corruption_reason, DBUS_ERROR_INVALID_ARGS, dbus_set_error(), and NULL\&.
.SS "int \fBdbus_message_demarshal_bytes_needed\fP (const char *buf, intlen)"
.PP
Returns the number of bytes required to be in the buffer to demarshal a D-Bus message\&. Generally, this function is only useful for encapsulating D-Bus messages in a different protocol\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP data to be marshalled 
.br
\fIlen\fP the length of str 
.br
\fIerror\fP the location to save errors to 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled\&. Otherwise returns the number of bytes to be demarshalled 
.RE
.PP

.PP
Definition at line 4663 of file dbus-message\&.c\&.
.PP
References _dbus_header_have_message_untrusted(), _dbus_string_free(), _dbus_string_init_const_len(), DBUS_MAXIMUM_MESSAGE_LENGTH, and DBUS_MINIMUM_HEADER_SIZE\&.
.SS "void \fBdbus_message_free_data_slot\fP (dbus_int32_t *slot_p)"
.PP
Deallocates a global ID for message data slots\&. \fBdbus_message_get_data()\fP and \fBdbus_message_set_data()\fP may no longer be used with this slot\&. Existing data stored on existing \fBDBusMessage\fP objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot)\&. When the refcount on the passed-in slot reaches 0, it is set to -1\&.
.PP
\fBParameters:\fP
.RS 4
\fIslot_p\fP address storing the slot to deallocate 
.RE
.PP

.PP
Definition at line 4399 of file dbus-message\&.c\&.
.PP
References _dbus_data_slot_allocator_free()\&.
.SS "void* \fBdbus_message_get_data\fP (\fBDBusMessage\fP *message, dbus_int32_tslot)"
.PP
Retrieves data previously set with \fBdbus_message_set_data()\fP\&. The slot must still be allocated (must not have been freed)\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message 
.br
\fIslot\fP the slot to get data from 
.RE
.PP
\fBReturns:\fP
.RS 4
the data, or \fBNULL\fP if not found 
.RE
.PP

.PP
Definition at line 4456 of file dbus-message\&.c\&.
.PP
References _dbus_data_slot_list_get(), NULL, and DBusMessage::slot_list\&.
.SS "void \fBdbus_message_lock\fP (\fBDBusMessage\fP *message)"
.PP
Locks a message\&. Allows checking that applications don't keep a reference to a message in the outgoing queue and change it underneath us\&. Messages are locked when they enter the outgoing queue (dbus_connection_send_message()), and the library complains if the message is modified while locked\&. This function may also called externally, for applications wrapping D-Bus in another protocol\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message to lock\&. 
.RE
.PP

.PP
Definition at line 329 of file dbus-message\&.c\&.
.PP
References _dbus_header_update_lengths(), DBusMessage::body, dbus_message_get_signature(), DBusMessage::header, DBusMessage::locked, NULL, and TRUE\&.
.PP
Referenced by dbus_message_marshal()\&.
.SS "\fBdbus_bool_t\fP \fBdbus_message_marshal\fP (\fBDBusMessage\fP *msg, char **marshalled_data_p, int *len_p)"
.PP
Turn a \fBDBusMessage\fP into the marshalled form as described in the D-Bus specification\&. Generally, this function is only useful for encapsulating D-Bus messages in a different protocol\&.
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP the \fBDBusMessage\fP 
.br
\fImarshalled_data_p\fP the location to save the marshalled form to 
.br
\fIlen_p\fP the location to save the length of the marshalled form to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if there was not enough memory 
.RE
.PP

.PP
Definition at line 4542 of file dbus-message\&.c\&.
.PP
References _dbus_string_copy(), _dbus_string_free(), _dbus_string_init(), _dbus_string_steal_data(), DBusMessage::body, DBusHeader::data, dbus_message_lock(), FALSE, DBusMessage::header, DBusMessage::locked, NULL, and TRUE\&.
.SS "\fBdbus_bool_t\fP \fBdbus_message_set_data\fP (\fBDBusMessage\fP *message, dbus_int32_tslot, void *data, \fBDBusFreeFunction\fPfree_data_func)"
.PP
Stores a pointer on a \fBDBusMessage\fP, along with an optional function to be used for freeing the data when the data is set again, or when the message is finalized\&. The slot number must have been allocated with \fBdbus_message_allocate_data_slot()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message 
.br
\fIslot\fP the slot number 
.br
\fIdata\fP the data to store 
.br
\fIfree_data_func\fP finalizer function for the data 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if there was enough memory to store the data 
.RE
.PP

.PP
Definition at line 4420 of file dbus-message\&.c\&.
.PP
References _dbus_data_slot_list_set(), FALSE, NULL, and DBusMessage::slot_list\&.
.SS "void \fBdbus_message_set_serial\fP (\fBDBusMessage\fP *message, dbus_uint32_tserial)"
.PP
Sets the serial number of a message\&. This can only be done once on a message\&.
.PP
\fBDBusConnection\fP will automatically set the serial to an appropriate value when the message is sent; this function is only needed when encapsulating messages in another protocol, or otherwise bypassing \fBDBusConnection\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fImessage\fP the message 
.br
\fIserial\fP the serial 
.RE
.PP

.PP
Definition at line 203 of file dbus-message\&.c\&.
.PP
References _dbus_header_set_serial(), DBusMessage::header, DBusMessage::locked, and NULL\&.
.PP
Referenced by dbus_connection_send_with_reply()\&.
.SS "int \fBdbus_message_type_from_string\fP (const char *type_str)"
.PP
Utility function to convert a machine-readable (not translated) string into a D-Bus message type\&. .PP
.nf
   'method_call'    -> DBUS_MESSAGE_TYPE_METHOD_CALL
   'method_return'  -> DBUS_MESSAGE_TYPE_METHOD_RETURN
   'signal'         -> DBUS_MESSAGE_TYPE_SIGNAL
   'error'          -> DBUS_MESSAGE_TYPE_ERROR
   anything else    -> DBUS_MESSAGE_TYPE_INVALID
.fi
.PP
 
.PP
Definition at line 4484 of file dbus-message\&.c\&.
.PP
References DBUS_MESSAGE_TYPE_ERROR, DBUS_MESSAGE_TYPE_INVALID, DBUS_MESSAGE_TYPE_METHOD_CALL, DBUS_MESSAGE_TYPE_METHOD_RETURN, and DBUS_MESSAGE_TYPE_SIGNAL\&.
.SS "const char* \fBdbus_message_type_to_string\fP (inttype)"
.PP
Utility function to convert a D-Bus message type into a machine-readable string (not translated)\&. .PP
.nf
   DBUS_MESSAGE_TYPE_METHOD_CALL    -> 'method_call'
   DBUS_MESSAGE_TYPE_METHOD_RETURN  -> 'method_return'
   DBUS_MESSAGE_TYPE_SIGNAL         -> 'signal'
   DBUS_MESSAGE_TYPE_ERROR          -> 'error'
   DBUS_MESSAGE_TYPE_INVALID        -> 'invalid'
.fi
.PP
 
.PP
Definition at line 4512 of file dbus-message\&.c\&.
.PP
References DBUS_MESSAGE_TYPE_ERROR, DBUS_MESSAGE_TYPE_METHOD_CALL, DBUS_MESSAGE_TYPE_METHOD_RETURN, and DBUS_MESSAGE_TYPE_SIGNAL\&.
.PP
Referenced by _dbus_connection_message_sent(), _dbus_connection_queue_received_message_link(), and dbus_connection_dispatch()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for D-Bus from the source code\&.
