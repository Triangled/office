.TH "Utilities and portability" 3dbus "Wed Mar 26 2014" "Version 1.4.18" "D-Bus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Utilities and portability \- 
.PP
Utility functions (_dbus_assert(), \fB_dbus_warn()\fP, etc\&.)  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBDBusBabysitter\fP"
.br
.RI "\fIBabysitter implementation details\&. \fP"
.ti -1c
.RI "struct \fBDBusDirIter\fP"
.br
.RI "\fIInternals of directory iterator\&. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBLIVE_CHILDREN\fP(sitter)   ((sitter)->socket_to_babysitter >= 0 || (sitter)->error_pipe_from_child >= 0)"
.br
.RI "\fIMacro returns \fBTRUE\fP if the babysitter still has live sockets open to the babysitter child or the grandchild\&. \fP"
.ti -1c
.RI "#define \fBREAD_END\fP   0"
.br
.RI "\fIHelps remember which end of the pipe is which\&. \fP"
.ti -1c
.RI "#define \fBWRITE_END\fP   1"
.br
.RI "\fIHelps remember which end of the pipe is which\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBReadStatus\fP { \fBREAD_STATUS_OK\fP, \fBREAD_STATUS_ERROR\fP, \fBREAD_STATUS_EOF\fP }"
.br
.RI "\fIEnumeration for status of a read() \fP"
.ti -1c
.RI "enum { \fBCHILD_EXITED\fP, \fBCHILD_FORK_FAILED\fP, \fBCHILD_EXEC_FAILED\fP, \fBCHILD_PID\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_dbus_warn\fP (const char *format,\&.\&.\&.)"
.br
.RI "\fIPrints a warning message to stderr\&. \fP"
.ti -1c
.RI "void \fB_dbus_warn_check_failed\fP (const char *format,\&.\&.\&.)"
.br
.RI "\fIPrints a 'critical' warning to stderr when an assertion fails; differs from _dbus_warn primarily in that it prefixes the pid and defaults to fatal\&. \fP"
.ti -1c
.RI "char * \fB_dbus_strdup\fP (const char *str)"
.br
.RI "\fIDuplicates a string\&. \fP"
.ti -1c
.RI "void * \fB_dbus_memdup\fP (const void *mem, size_t n_bytes)"
.br
.RI "\fIDuplicates a block of memory\&. \fP"
.ti -1c
.RI "char ** \fB_dbus_dup_string_array\fP (const char **array)"
.br
.RI "\fIDuplicates a string array\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_string_array_contains\fP (const char **array, const char *str)"
.br
.RI "\fIChecks whether a string array contains the given string\&. \fP"
.ti -1c
.RI "void \fB_dbus_generate_uuid\fP (\fBDBusGUID\fP *uuid)"
.br
.RI "\fIGenerates a new UUID\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_uuid_encode\fP (const \fBDBusGUID\fP *uuid, \fBDBusString\fP *encoded)"
.br
.RI "\fIHex-encode a UUID\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_read_uuid_file\fP (const \fBDBusString\fP *filename, \fBDBusGUID\fP *uuid, \fBdbus_bool_t\fP create_if_not_found, \fBDBusError\fP *error)"
.br
.RI "\fIReads (and optionally writes) a uuid to a file\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_local_machine_uuid_encoded\fP (\fBDBusString\fP *uuid_str)"
.br
.RI "\fIGets the hex-encoded UUID of the machine this function is executed on\&. \fP"
.ti -1c
.RI "void \fB_dbus_real_assert\fP (\fBdbus_bool_t\fP condition, const char *condition_text, const char *file, int line, const char *func)"
.br
.RI "\fIInternals of _dbus_assert(); it's a function rather than a macro with the inline code so that the assertion failure blocks don't show up in test suite coverage, and to shrink code size\&. \fP"
.ti -1c
.RI "void \fB_dbus_real_assert_not_reached\fP (const char *explanation, const char *file, int line)"
.br
.RI "\fIInternals of _dbus_assert_not_reached(); it's a function rather than a macro with the inline code so that the assertion failure blocks don't show up in test suite coverage, and to shrink code size\&. \fP"
.ti -1c
.RI "\fBDBusBabysitter\fP * \fB_dbus_babysitter_ref\fP (\fBDBusBabysitter\fP *sitter)"
.br
.RI "\fIIncrement the reference count on the babysitter object\&. \fP"
.ti -1c
.RI "void \fB_dbus_babysitter_unref\fP (\fBDBusBabysitter\fP *sitter)"
.br
.RI "\fIDecrement the reference count on the babysitter object\&. \fP"
.ti -1c
.RI "void \fB_dbus_babysitter_kill_child\fP (\fBDBusBabysitter\fP *sitter)"
.br
.RI "\fIBlocks until the babysitter process gives us the PID of the spawned grandchild, then kills the spawned grandchild\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_babysitter_get_child_exited\fP (\fBDBusBabysitter\fP *sitter)"
.br
.RI "\fIChecks whether the child has exited, without blocking\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_babysitter_get_child_exit_status\fP (\fBDBusBabysitter\fP *sitter, int *status)"
.br
.RI "\fIGets the exit status of the child\&. \fP"
.ti -1c
.RI "void \fB_dbus_babysitter_set_child_exit_error\fP (\fBDBusBabysitter\fP *sitter, \fBDBusError\fP *error)"
.br
.RI "\fISets the \fBDBusError\fP with an explanation of why the spawned child process exited (on a signal, or whatever)\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_babysitter_set_watch_functions\fP (\fBDBusBabysitter\fP *sitter, \fBDBusAddWatchFunction\fP add_function, \fBDBusRemoveWatchFunction\fP remove_function, \fBDBusWatchToggledFunction\fP toggled_function, void *data, \fBDBusFreeFunction\fP free_data_function)"
.br
.RI "\fISets watch functions to notify us when the babysitter object needs to read/write file descriptors\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_spawn_async_with_babysitter\fP (\fBDBusBabysitter\fP **sitter_p, char **argv, char **env, DBusSpawnChildSetupFunc child_setup, void *user_data, \fBDBusError\fP *error)"
.br
.RI "\fISpawns a new process\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_become_daemon\fP (const \fBDBusString\fP *pidfile, \fBDBusPipe\fP *print_pid_pipe, \fBDBusError\fP *error, \fBdbus_bool_t\fP keep_umask)"
.br
.RI "\fIDoes the chdir, fork, setsid, etc\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_write_pid_to_file_and_pipe\fP (const \fBDBusString\fP *pidfile, \fBDBusPipe\fP *print_pid_pipe, \fBdbus_pid_t\fP pid_to_write, \fBDBusError\fP *error)"
.br
.RI "\fIWrites the given pid_to_write to a pidfile (if non-NULL) and/or to a pipe (if non-NULL)\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_verify_daemon_user\fP (const char *user)"
.br
.RI "\fIVerify that after the fork we can successfully change to this user\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_change_to_daemon_user\fP (const char *user, \fBDBusError\fP *error)"
.br
.RI "\fIChanges the user and group the bus is running as\&. \fP"
.ti -1c
.RI "void \fB_dbus_request_file_descriptor_limit\fP (unsigned int limit)"
.br
.RI "\fIAttempt to ensure that the current process can open at least  file descriptors\&. \fP"
.ti -1c
.RI "void \fB_dbus_init_system_log\fP (void)"
.br
.ti -1c
.RI "void \fB_dbus_system_log\fP (DBusSystemLogSeverity severity, const char *msg,\&.\&.\&.)"
.br
.RI "\fILog a message to the system log file (e\&.g\&. \fP"
.ti -1c
.RI "void \fB_dbus_system_logv\fP (DBusSystemLogSeverity severity, const char *msg, va_list args)"
.br
.RI "\fILog a message to the system log file (e\&.g\&. \fP"
.ti -1c
.RI "void \fB_dbus_set_signal_handler\fP (int sig, \fBDBusSignalHandler\fP handler)"
.br
.RI "\fIInstalls a UNIX signal handler\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_file_exists\fP (const char *file)"
.br
.RI "\fIChecks if a file exists\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_user_at_console\fP (const char *username, \fBDBusError\fP *error)"
.br
.RI "\fIChecks if user is at the console\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_path_is_absolute\fP (const \fBDBusString\fP *filename)"
.br
.RI "\fIChecks whether the filename is an absolute path\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_stat\fP (const \fBDBusString\fP *filename, \fBDBusStat\fP *statbuf, \fBDBusError\fP *error)"
.br
.RI "\fIstat() wrapper\&. \fP"
.ti -1c
.RI "\fBDBusDirIter\fP * \fB_dbus_directory_open\fP (const \fBDBusString\fP *filename, \fBDBusError\fP *error)"
.br
.RI "\fIOpen a directory to iterate over\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_directory_get_next_file\fP (\fBDBusDirIter\fP *iter, \fBDBusString\fP *filename, \fBDBusError\fP *error)"
.br
.RI "\fIGet next file in the directory\&. \fP"
.ti -1c
.RI "void \fB_dbus_directory_close\fP (\fBDBusDirIter\fP *iter)"
.br
.RI "\fICloses a directory iteration\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_group_info_fill\fP (\fBDBusGroupInfo\fP *info, const \fBDBusString\fP *groupname, \fBDBusError\fP *error)"
.br
.RI "\fIInitializes the given \fBDBusGroupInfo\fP struct with information about the given group name\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_group_info_fill_gid\fP (\fBDBusGroupInfo\fP *info, \fBdbus_gid_t\fP gid, \fBDBusError\fP *error)"
.br
.RI "\fIInitializes the given \fBDBusGroupInfo\fP struct with information about the given group ID\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_parse_unix_user_from_config\fP (const \fBDBusString\fP *username, \fBdbus_uid_t\fP *uid_p)"
.br
.RI "\fIParse a UNIX user from the bus config file\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_parse_unix_group_from_config\fP (const \fBDBusString\fP *groupname, \fBdbus_gid_t\fP *gid_p)"
.br
.RI "\fIParse a UNIX group from the bus config file\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_unix_groups_from_uid\fP (\fBdbus_uid_t\fP uid, \fBdbus_gid_t\fP **group_ids, int *n_group_ids)"
.br
.RI "\fIGets all groups corresponding to the given UNIX user ID\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_unix_user_is_at_console\fP (\fBdbus_uid_t\fP uid, \fBDBusError\fP *error)"
.br
.RI "\fIChecks to see if the UNIX user ID is at the console\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_unix_user_is_process_owner\fP (\fBdbus_uid_t\fP uid)"
.br
.RI "\fIChecks to see if the UNIX user ID matches the UID of the process\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_windows_user_is_process_owner\fP (const char *windows_sid)"
.br
.RI "\fIChecks to see if the Windows user SID matches the owner of the process\&. \fP"
.ti -1c
.RI "void \fB_dbus_generate_pseudorandom_bytes_buffer\fP (char *buffer, int n_bytes)"
.br
.RI "\fIRandom numbers\&. \fP"
.ti -1c
.RI "void \fB_dbus_generate_random_bytes_buffer\fP (char *buffer, int n_bytes)"
.br
.RI "\fIFills n_bytes of the given buffer with random bytes\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_generate_random_ascii\fP (\fBDBusString\fP *str, int n_bytes)"
.br
.RI "\fIGenerates the given number of random bytes, where the bytes are chosen from the alphanumeric ASCII subset\&. \fP"
.ti -1c
.RI "const char * \fB_dbus_error_from_errno\fP (int error_number)"
.br
.RI "\fIConverts a UNIX errno, or Windows errno or WinSock error value into a \fBDBusError\fP name\&. \fP"
.ti -1c
.RI "const char * \fB_dbus_error_from_system_errno\fP (void)"
.br
.RI "\fIConverts the current system errno value into a \fBDBusError\fP name\&. \fP"
.ti -1c
.RI "void \fB_dbus_set_errno_to_zero\fP (void)"
.br
.RI "\fIAssign 0 to the global errno variable\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_nonzero\fP (void)"
.br
.RI "\fISee if errno is set\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_enomem\fP (void)"
.br
.RI "\fISee if errno is ENOMEM\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_eintr\fP (void)"
.br
.RI "\fISee if errno is EINTR\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_epipe\fP (void)"
.br
.RI "\fISee if errno is EPIPE\&. \fP"
.ti -1c
.RI "const char * \fB_dbus_strerror_from_errno\fP (void)"
.br
.RI "\fIGet error message from errno\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_is_console_user\fP (\fBdbus_uid_t\fP uid, \fBDBusError\fP *error)"
.br
.RI "\fIChecks to see if the UID sent in is the console user\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_user_id\fP (const \fBDBusString\fP *username, \fBdbus_uid_t\fP *uid)"
.br
.RI "\fIGets user ID given username\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_group_id\fP (const \fBDBusString\fP *groupname, \fBdbus_gid_t\fP *gid)"
.br
.RI "\fIGets group ID given groupname\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_get_user_id_and_primary_group\fP (const \fBDBusString\fP *username, \fBdbus_uid_t\fP *uid_p, \fBdbus_gid_t\fP *gid_p)"
.br
.RI "\fIGets user ID and primary group given username\&. \fP"
.ti -1c
.RI "\fBDBusGroupInfo\fP * \fB_dbus_user_database_lookup_group\fP (DBusUserDatabase *db, \fBdbus_gid_t\fP gid, const \fBDBusString\fP *groupname, \fBDBusError\fP *error)"
.br
.RI "\fILooks up a gid or group name in the user database\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_user_database_get_groupname\fP (DBusUserDatabase *db, const \fBDBusString\fP *groupname, const \fBDBusGroupInfo\fP **info, \fBDBusError\fP *error)"
.br
.RI "\fIGets the user information for the given group name, returned group info should not be freed\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_user_database_get_gid\fP (DBusUserDatabase *db, \fBdbus_gid_t\fP gid, const \fBDBusGroupInfo\fP **info, \fBDBusError\fP *error)"
.br
.RI "\fIGets the user information for the given GID, returned group info should not be freed\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_groups_from_uid\fP (\fBdbus_uid_t\fP uid, \fBdbus_gid_t\fP **group_ids, int *n_group_ids)"
.br
.RI "\fIGets all groups corresponding to the given UID\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_info_free_allocated\fP (\fBDBusUserInfo\fP *info)"
.br
.RI "\fIFrees the given \fBDBusUserInfo\fP's members with \fB_dbus_user_info_free()\fP and also calls \fBdbus_free()\fP on the block itself\&. \fP"
.ti -1c
.RI "void \fB_dbus_group_info_free_allocated\fP (\fBDBusGroupInfo\fP *info)"
.br
.RI "\fIFrees the given \fBDBusGroupInfo\fP's members with \fB_dbus_group_info_free()\fP and also calls \fBdbus_free()\fP on the block itself\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_info_free\fP (\fBDBusUserInfo\fP *info)"
.br
.RI "\fIFrees the members of info (but not info itself) \fP"
.ti -1c
.RI "void \fB_dbus_group_info_free\fP (\fBDBusGroupInfo\fP *info)"
.br
.RI "\fIFrees the members of info (but not info itself)\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_is_a_number\fP (const \fBDBusString\fP *str, unsigned long *num)"
.br
.RI "\fIChecks if a given string is actually a number and converts it if it is\&. \fP"
.ti -1c
.RI "\fBDBusUserInfo\fP * \fB_dbus_user_database_lookup\fP (DBusUserDatabase *db, \fBdbus_uid_t\fP uid, const \fBDBusString\fP *username, \fBDBusError\fP *error)"
.br
.RI "\fILooks up a uid or username in the user database\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_database_lock_system\fP (void)"
.br
.RI "\fILocks global system user database\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_database_unlock_system\fP (void)"
.br
.RI "\fIUnlocks global system user database\&. \fP"
.ti -1c
.RI "DBusUserDatabase * \fB_dbus_user_database_get_system\fP (void)"
.br
.RI "\fIGets the system global user database; must be called with lock held (\fB_dbus_user_database_lock_system()\fP)\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_database_flush_system\fP (void)"
.br
.RI "\fIFlushes the system global user database;\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_username_from_current_process\fP (const \fBDBusString\fP **username)"
.br
.RI "\fIGets username of user owning current process\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_homedir_from_current_process\fP (const \fBDBusString\fP **homedir)"
.br
.RI "\fIGets homedir of user owning current process\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_homedir_from_username\fP (const \fBDBusString\fP *username, \fBDBusString\fP *homedir)"
.br
.RI "\fIGets the home directory for the given user\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_homedir_from_uid\fP (\fBdbus_uid_t\fP uid, \fBDBusString\fP *homedir)"
.br
.RI "\fIGets the home directory for the given user\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_credentials_add_from_user\fP (\fBDBusCredentials\fP *credentials, const \fBDBusString\fP *username)"
.br
.RI "\fIAdds the credentials corresponding to the given username\&. \fP"
.ti -1c
.RI "DBusUserDatabase * \fB_dbus_user_database_new\fP (void)"
.br
.RI "\fICreates a new user database object used to look up and cache user information\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_database_flush\fP (DBusUserDatabase *db)"
.br
.RI "\fIFlush all information out of the user database\&. \fP"
.ti -1c
.RI "void \fB_dbus_user_database_unref\fP (DBusUserDatabase *db)"
.br
.RI "\fIDecrements refcount of user database\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_user_database_get_uid\fP (DBusUserDatabase *db, \fBdbus_uid_t\fP uid, const \fBDBusUserInfo\fP **info, \fBDBusError\fP *error)"
.br
.RI "\fIGets the user information for the given UID, returned user info should not be freed\&. \fP"
.ti -1c
.RI "\fBdbus_bool_t\fP \fB_dbus_user_database_get_username\fP (DBusUserDatabase *db, const \fBDBusString\fP *username, const \fBDBusUserInfo\fP **info, \fBDBusError\fP *error)"
.br
.RI "\fIGets the user information for the given username\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char * \fB_dbus_no_memory_message\fP = 'Not enough memory'"
.br
.RI "\fIFixed 'out of memory' error message, just to avoid making up a different string every time and wasting space\&. \fP"
.ti -1c
.RI "const char * \fB_dbus_return_if_fail_warning_format\fP = 'This is normally a bug in some application using the D-Bus library\&.\\n'"
.br
.RI "\fIString used in _dbus_return_if_fail macro\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Utility functions (_dbus_assert(), \fB_dbus_warn()\fP, etc\&.) 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBReadStatus\fP"
.PP
Enumeration for status of a read() 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIREAD_STATUS_OK \fP\fP
Read succeeded\&. 
.TP
\fB\fIREAD_STATUS_ERROR \fP\fP
Some kind of error\&. 
.TP
\fB\fIREAD_STATUS_EOF \fP\fP
EOF returned\&. 
.PP
Definition at line 57 of file dbus-spawn\&.c\&.
.SH "Function Documentation"
.PP 
.SS "\fBdbus_bool_t\fP \fB_dbus_babysitter_get_child_exit_status\fP (\fBDBusBabysitter\fP *sitter, int *status)"
.PP
Gets the exit status of the child\&. We do this so implementation specific detail is not cluttering up dbus, for example the system launcher code\&. This can only be called if the child has exited, i\&.e\&. call \fB_dbus_babysitter_get_child_exited()\fP\&. It returns FALSE if the child did not return a status code, e\&.g\&. because the child was signaled or we failed to ever launch the child in the first place\&.
.PP
\fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter 
.br
\fIstatus\fP the returned status code 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP on failure 
.RE
.PP

.PP
Definition at line 653 of file dbus-spawn\&.c\&.
.PP
References _dbus_babysitter_get_child_exited(), FALSE, DBusBabysitter::status, and TRUE\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_babysitter_get_child_exited\fP (\fBDBusBabysitter\fP *sitter)"
.PP
Checks whether the child has exited, without blocking\&. \fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter 
.RE
.PP

.PP
Definition at line 628 of file dbus-spawn\&.c\&.
.PP
References FALSE, LIVE_CHILDREN, NULL, and DBusBabysitter::socket_to_babysitter\&.
.PP
Referenced by _dbus_babysitter_get_child_exit_status(), and _dbus_babysitter_set_child_exit_error()\&.
.SS "void \fB_dbus_babysitter_kill_child\fP (\fBDBusBabysitter\fP *sitter)"
.PP
Blocks until the babysitter process gives us the PID of the spawned grandchild, then kills the spawned grandchild\&. \fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter object 
.RE
.PP

.PP
Definition at line 606 of file dbus-spawn\&.c\&.
.PP
References DBusBabysitter::grandchild_pid, LIVE_CHILDREN, NULL, and TRUE\&.
.SS "\fBDBusBabysitter\fP* \fB_dbus_babysitter_ref\fP (\fBDBusBabysitter\fP *sitter)"
.PP
Increment the reference count on the babysitter object\&. \fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter 
.RE
.PP
\fBReturns:\fP
.RS 4
the babysitter 
.RE
.PP

.PP
Definition at line 250 of file dbus-spawn\&.c\&.
.PP
References NULL, and DBusBabysitter::refcount\&.
.SS "void \fB_dbus_babysitter_set_child_exit_error\fP (\fBDBusBabysitter\fP *sitter, \fBDBusError\fP *error)"
.PP
Sets the \fBDBusError\fP with an explanation of why the spawned child process exited (on a signal, or whatever)\&. If the child process has not exited, does nothing (error will remain unset)\&.
.PP
\fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter 
.br
\fIerror\fP an error to fill in 
.RE
.PP

.PP
Definition at line 677 of file dbus-spawn\&.c\&.
.PP
References _dbus_babysitter_get_child_exited(), DBUS_ERROR_FAILED, DBUS_ERROR_NO_MEMORY, DBUS_ERROR_SPAWN_CHILD_EXITED, DBUS_ERROR_SPAWN_CHILD_SIGNALED, DBUS_ERROR_SPAWN_EXEC_FAILED, dbus_set_error(), DBusBabysitter::errnum, DBusBabysitter::executable, DBusBabysitter::have_exec_errnum, DBusBabysitter::have_fork_errnum, and DBusBabysitter::status\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_babysitter_set_watch_functions\fP (\fBDBusBabysitter\fP *sitter, \fBDBusAddWatchFunction\fPadd_function, \fBDBusRemoveWatchFunction\fPremove_function, \fBDBusWatchToggledFunction\fPtoggled_function, void *data, \fBDBusFreeFunction\fPfree_data_function)"
.PP
Sets watch functions to notify us when the babysitter object needs to read/write file descriptors\&. \fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter 
.br
\fIadd_function\fP function to begin monitoring a new descriptor\&. 
.br
\fIremove_function\fP function to stop monitoring a descriptor\&. 
.br
\fItoggled_function\fP function to notify when the watch is enabled/disabled 
.br
\fIdata\fP data to pass to add_function and remove_function\&. 
.br
\fIfree_data_function\fP function to be called to free the data\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP on failure (no memory) 
.RE
.PP

.PP
Definition at line 735 of file dbus-spawn\&.c\&.
.PP
References _dbus_watch_list_set_functions(), and DBusBabysitter::watches\&.
.SS "void \fB_dbus_babysitter_unref\fP (\fBDBusBabysitter\fP *sitter)"
.PP
Decrement the reference count on the babysitter object\&. When the reference count of the babysitter object reaches zero, the babysitter is killed and the child that was being babysat gets emancipated\&.
.PP
\fBParameters:\fP
.RS 4
\fIsitter\fP the babysitter 
.RE
.PP

.PP
Definition at line 269 of file dbus-spawn\&.c\&.
.PP
References _dbus_close_socket(), _dbus_warn(), _dbus_watch_invalidate(), _dbus_watch_list_free(), _dbus_watch_unref(), dbus_free(), DBusBabysitter::error_pipe_from_child, DBusBabysitter::error_watch, DBusBabysitter::executable, NULL, DBusBabysitter::refcount, DBusBabysitter::sitter_pid, DBusBabysitter::sitter_watch, DBusBabysitter::socket_to_babysitter, DBusBabysitter::status, and DBusBabysitter::watches\&.
.PP
Referenced by _dbus_spawn_async_with_babysitter()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_become_daemon\fP (const \fBDBusString\fP *pidfile, \fBDBusPipe\fP *print_pid_pipe, \fBDBusError\fP *error, \fBdbus_bool_t\fPkeep_umask)"
.PP
Does the chdir, fork, setsid, etc\&. to become a daemon process\&.
.PP
\fBParameters:\fP
.RS 4
\fIpidfile\fP \fBNULL\fP, or pidfile to create 
.br
\fIprint_pid_pipe\fP pipe to print daemon's pid to, or -1 for none 
.br
\fIerror\fP return location for errors 
.br
\fIkeep_umask\fP \fBTRUE\fP to keep the original umask 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP on failure 
.RE
.PP

.PP
Definition at line 78 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_change_to_daemon_user\fP (const char *user, \fBDBusError\fP *error)"
.PP
Changes the user and group the bus is running as\&. \fBParameters:\fP
.RS 4
\fIuser\fP the user to become 
.br
\fIerror\fP return location for errors 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP on failure 
.RE
.PP

.PP
Definition at line 324 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_credentials_add_from_user\fP (\fBDBusCredentials\fP *credentials, const \fBDBusString\fP *username)"
.PP
Adds the credentials corresponding to the given username\&. Used among other purposes to parses a desired identity provided from a client in the auth protocol\&. On UNIX this means parsing a UID, on Windows probably parsing an SID string\&.
.PP
\fBTodo\fP
.RS 4
this is broken because it treats OOM and parse error the same way\&. Needs a \fBDBusError\fP\&.
.RE
.PP
.PP
\fBParameters:\fP
.RS 4
\fIcredentials\fP credentials to fill in 
.br
\fIusername\fP the username 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if the username existed and we got some credentials 
.RE
.PP

.PP
Definition at line 493 of file dbus-userdb\&.c\&.
.PP
References _dbus_credentials_add_unix_uid(), _dbus_credentials_add_windows_sid(), _dbus_user_database_get_system(), _dbus_user_database_get_username(), _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, NULL, TRUE, and DBusUserInfo::uid\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_directory_get_next_file\fP (\fBDBusDirIter\fP *iter, \fBDBusString\fP *filename, \fBDBusError\fP *error)"
.PP
Get next file in the directory\&. Will not return '\&.' or '\&.\&.' on UNIX\&. If an error occurs, the contents of 'filename' are undefined\&. The error is never set if the function succeeds\&.
.PP
This function is not re-entrant, and not necessarily thread-safe\&. Only use it for test code or single-threaded utilities\&.
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator 
.br
\fIfilename\fP string to be set to the next file in the dir 
.br
\fIerror\fP return location for error 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if filename was filled in with a new filename 
.RE
.PP

.PP
Definition at line 696 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBDBusDirIter\fP* \fB_dbus_directory_open\fP (const \fBDBusString\fP *filename, \fBDBusError\fP *error)"
.PP
Open a directory to iterate over\&. \fBParameters:\fP
.RS 4
\fIfilename\fP the directory name 
.br
\fIerror\fP exception return object or \fBNULL\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
new iterator, or \fBNULL\fP on error 
.RE
.PP

.PP
Definition at line 648 of file dbus-sysdeps-util-unix\&.c\&.
.SS "char** \fB_dbus_dup_string_array\fP (const char **array)"
.PP
Duplicates a string array\&. Result may be freed with \fBdbus_free_string_array()\fP\&. Returns \fBNULL\fP if memory allocation fails\&. If the array to be duplicated is \fBNULL\fP, returns \fBNULL\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIarray\fP array to duplicate\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
newly-allocated copy\&. 
.RE
.PP

.PP
Definition at line 531 of file dbus-internals\&.c\&.
.PP
References _dbus_strdup(), dbus_free_string_array(), dbus_new0, and NULL\&.
.PP
Referenced by _dbus_auth_set_mechanisms(), and dbus_server_set_auth_mechanisms()\&.
.SS "const char* \fB_dbus_error_from_errno\fP (interror_number)"
.PP
Converts a UNIX errno, or Windows errno or WinSock error value into a \fBDBusError\fP name\&. \fBTodo\fP
.RS 4
should cover more errnos, specifically those from open()\&.
.RE
.PP
.PP
\fBParameters:\fP
.RS 4
\fIerror_number\fP the errno\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
an error name 
.RE
.PP

.PP
Definition at line 909 of file dbus-sysdeps\&.c\&.
.PP
References DBUS_ERROR_ACCESS_DENIED, DBUS_ERROR_ADDRESS_IN_USE, DBUS_ERROR_FAILED, DBUS_ERROR_FILE_EXISTS, DBUS_ERROR_FILE_NOT_FOUND, DBUS_ERROR_LIMITS_EXCEEDED, DBUS_ERROR_NO_MEMORY, DBUS_ERROR_NO_NETWORK, DBUS_ERROR_NO_SERVER, DBUS_ERROR_NOT_SUPPORTED, and DBUS_ERROR_TIMEOUT\&.
.PP
Referenced by _dbus_become_daemon(), _dbus_change_to_daemon_user(), _dbus_check_dir_is_private_to_user(), _dbus_close(), _dbus_close_socket(), _dbus_command_for_pid(), _dbus_connect_unix_socket(), _dbus_directory_get_next_file(), _dbus_directory_open(), _dbus_dup(), _dbus_error_from_system_errno(), _dbus_file_get_contents(), _dbus_full_duplex_pipe(), _dbus_listen_systemd_sockets(), _dbus_listen_tcp_socket(), _dbus_listen_unix_socket(), _dbus_read_credentials_socket(), _dbus_send_credentials_socket(), _dbus_stat(), and _dbus_string_save_to_file()\&.
.SS "const char* \fB_dbus_error_from_system_errno\fP (void)"
.PP
Converts the current system errno value into a \fBDBusError\fP name\&. \fBReturns:\fP
.RS 4
an error name 
.RE
.PP

.PP
Definition at line 1007 of file dbus-sysdeps\&.c\&.
.PP
References _dbus_error_from_errno()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_file_exists\fP (const char *file)"
.PP
Checks if a file exists\&. File interface\&.
.PP
\fBParameters:\fP
.RS 4
\fIfile\fP full path to the file 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if file exists 
.RE
.PP

.PP
Definition at line 528 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_generate_random_ascii\fP (\fBDBusString\fP *str, intn_bytes)"
.PP
Generates the given number of random bytes, where the bytes are chosen from the alphanumeric ASCII subset\&. \fBParameters:\fP
.RS 4
\fIstr\fP the string 
.br
\fIn_bytes\fP the number of random ASCII bytes to append to string 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP on success, \fBFALSE\fP if no memory or other failure 
.RE
.PP

.PP
Definition at line 870 of file dbus-sysdeps\&.c\&.
.PP
References _dbus_generate_random_bytes(), _dbus_string_validate_ascii(), FALSE, and TRUE\&.
.PP
Referenced by _dbus_server_listen_platform_specific(), and _dbus_string_save_to_file()\&.
.SS "void \fB_dbus_generate_random_bytes_buffer\fP (char *buffer, intn_bytes)"
.PP
Fills n_bytes of the given buffer with random bytes\&. \fBParameters:\fP
.RS 4
\fIbuffer\fP an allocated buffer 
.br
\fIn_bytes\fP the number of bytes in buffer to write to 
.RE
.PP

.PP
Definition at line 838 of file dbus-sysdeps\&.c\&.
.PP
References _dbus_generate_pseudorandom_bytes_buffer(), _dbus_generate_random_bytes(), _dbus_string_copy_to_buffer(), _dbus_string_free(), and _dbus_string_init()\&.
.PP
Referenced by _dbus_generate_uuid()\&.
.SS "void \fB_dbus_generate_uuid\fP (\fBDBusGUID\fP *uuid)"
.PP
Generates a new UUID\&. If you change how this is done, there's some text about it in the spec that should also change\&.
.PP
\fBParameters:\fP
.RS 4
\fIuuid\fP the uuid to initialize 
.RE
.PP

.PP
Definition at line 594 of file dbus-internals\&.c\&.
.PP
References _dbus_generate_random_bytes_buffer(), _dbus_get_current_time(), and NULL\&.
.PP
Referenced by _dbus_get_local_machine_uuid_encoded(), _dbus_server_init_base(), and dbus_internal_do_not_use_create_uuid()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_group_id\fP (const \fBDBusString\fP *groupname, \fBdbus_gid_t\fP *gid)"
.PP
Gets group ID given groupname\&. \fBParameters:\fP
.RS 4
\fIgroupname\fP the groupname 
.br
\fIgid\fP return location for GID 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if group name existed and we got the GID 
.RE
.PP

.PP
Definition at line 129 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_user_database_get_groupname(), _dbus_user_database_get_system(), _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, DBusGroupInfo::gid, NULL, and TRUE\&.
.PP
Referenced by _dbus_parse_unix_group_from_config()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_eintr\fP (void)"
.PP
See if errno is EINTR\&. \fBReturns:\fP
.RS 4
\fBTRUE\fP if errno == EINTR 
.RE
.PP

.PP
Definition at line 1050 of file dbus-sysdeps\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_enomem\fP (void)"
.PP
See if errno is ENOMEM\&. \fBReturns:\fP
.RS 4
\fBTRUE\fP if errno == ENOMEM 
.RE
.PP

.PP
Definition at line 1040 of file dbus-sysdeps\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_epipe\fP (void)"
.PP
See if errno is EPIPE\&. \fBReturns:\fP
.RS 4
\fBTRUE\fP if errno == EPIPE 
.RE
.PP

.PP
Definition at line 1060 of file dbus-sysdeps\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_is_errno_nonzero\fP (void)"
.PP
See if errno is set\&. \fBReturns:\fP
.RS 4
\fBTRUE\fP if errno is not 0 
.RE
.PP

.PP
Definition at line 1030 of file dbus-sysdeps\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_local_machine_uuid_encoded\fP (\fBDBusString\fP *uuid_str)"
.PP
Gets the hex-encoded UUID of the machine this function is executed on\&. This UUID is guaranteed to be the same for a given machine at least until it next reboots, though it also makes some effort to be the same forever, it may change if the machine is reconfigured or its hardware is modified\&.
.PP
\fBParameters:\fP
.RS 4
\fIuuid_str\fP string to append hex-encoded machine uuid to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if no memory 
.RE
.PP

.PP
Definition at line 797 of file dbus-internals\&.c\&.
.PP
References _dbus_current_generation, _dbus_generate_uuid(), _dbus_read_local_machine_uuid(), _dbus_uuid_encode(), _dbus_warn_check_failed(), dbus_error_free(), DBUS_ERROR_INIT, FALSE, and DBusError::message\&.
.PP
Referenced by _dbus_get_autolaunch_address(), and dbus_get_local_machine_id()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_user_id\fP (const \fBDBusString\fP *username, \fBdbus_uid_t\fP *uid)"
.PP
Gets user ID given username\&. \fBParameters:\fP
.RS 4
\fIusername\fP the username 
.br
\fIuid\fP return location for UID 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if username existed and we got the UID 
.RE
.PP

.PP
Definition at line 115 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_get_user_id_and_primary_group(), and NULL\&.
.PP
Referenced by _dbus_parse_unix_user_from_config()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_get_user_id_and_primary_group\fP (const \fBDBusString\fP *username, \fBdbus_uid_t\fP *uid_p, \fBdbus_gid_t\fP *gid_p)"
.PP
Gets user ID and primary group given username\&. \fBParameters:\fP
.RS 4
\fIusername\fP the username 
.br
\fIuid_p\fP return location for UID 
.br
\fIgid_p\fP return location for GID 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if username existed and we got the UID and GID 
.RE
.PP

.PP
Definition at line 165 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_user_database_get_system(), _dbus_user_database_get_username(), _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, NULL, DBusUserInfo::primary_gid, TRUE, and DBusUserInfo::uid\&.
.PP
Referenced by _dbus_change_to_daemon_user(), _dbus_get_user_id(), and _dbus_verify_daemon_user()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_group_info_fill\fP (\fBDBusGroupInfo\fP *info, const \fBDBusString\fP *groupname, \fBDBusError\fP *error)"
.PP
Initializes the given \fBDBusGroupInfo\fP struct with information about the given group name\&. \fBParameters:\fP
.RS 4
\fIinfo\fP the group info struct 
.br
\fIgroupname\fP name of group 
.br
\fIerror\fP the error return 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error is set 
.RE
.PP

.PP
Definition at line 894 of file dbus-sysdeps-util-unix\&.c\&.
.PP
References DBUS_GID_UNSET\&.
.PP
Referenced by _dbus_user_database_lookup_group()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_group_info_fill_gid\fP (\fBDBusGroupInfo\fP *info, \fBdbus_gid_t\fPgid, \fBDBusError\fP *error)"
.PP
Initializes the given \fBDBusGroupInfo\fP struct with information about the given group ID\&. \fBParameters:\fP
.RS 4
\fIinfo\fP the group info struct 
.br
\fIgid\fP group ID 
.br
\fIerror\fP the error return 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error is set 
.RE
.PP

.PP
Definition at line 913 of file dbus-sysdeps-util-unix\&.c\&.
.PP
References NULL\&.
.PP
Referenced by _dbus_user_database_lookup_group()\&.
.SS "void \fB_dbus_group_info_free\fP (\fBDBusGroupInfo\fP *info)"
.PP
Frees the members of info (but not info itself)\&. \fBParameters:\fP
.RS 4
\fIinfo\fP the group info 
.RE
.PP

.PP
Definition at line 89 of file dbus-userdb\&.c\&.
.PP
References dbus_free(), and DBusGroupInfo::groupname\&.
.PP
Referenced by _dbus_group_info_free_allocated()\&.
.SS "void \fB_dbus_group_info_free_allocated\fP (\fBDBusGroupInfo\fP *info)"
.PP
Frees the given \fBDBusGroupInfo\fP's members with \fB_dbus_group_info_free()\fP and also calls \fBdbus_free()\fP on the block itself\&. \fBParameters:\fP
.RS 4
\fIinfo\fP the info 
.RE
.PP

.PP
Definition at line 61 of file dbus-userdb\&.c\&.
.PP
References _dbus_group_info_free(), dbus_free(), and NULL\&.
.PP
Referenced by _dbus_user_database_lookup_group(), and _dbus_user_database_new()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_groups_from_uid\fP (\fBdbus_uid_t\fPuid, \fBdbus_gid_t\fP **group_ids, int *n_group_ids)"
.PP
Gets all groups corresponding to the given UID\&. Returns \fBFALSE\fP if no memory, or user isn't known, but always initializes group_ids to a NULL array\&.
.PP
\fBParameters:\fP
.RS 4
\fIuid\fP the UID 
.br
\fIgroup_ids\fP return location for array of group IDs 
.br
\fIn_group_ids\fP return location for length of returned array 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if the UID existed and we got some credentials 
.RE
.PP

.PP
Definition at line 355 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_user_database_get_system(), _dbus_user_database_get_uid(), _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), dbus_new, FALSE, DBusUserInfo::group_ids, DBusUserInfo::n_group_ids, NULL, TRUE, and DBusUserInfo::uid\&.
.PP
Referenced by _dbus_unix_groups_from_uid()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_homedir_from_current_process\fP (const \fBDBusString\fP **homedir)"
.PP
Gets homedir of user owning current process\&. The returned string is valid until \fBdbus_shutdown()\fP is called\&.
.PP
\fBParameters:\fP
.RS 4
\fIhomedir\fP place to store pointer to homedir 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if no memory 
.RE
.PP

.PP
Definition at line 386 of file dbus-userdb\&.c\&.
.PP
References _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, and TRUE\&.
.PP
Referenced by _dbus_get_standard_session_servicedirs()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_homedir_from_uid\fP (\fBdbus_uid_t\fPuid, \fBDBusString\fP *homedir)"
.PP
Gets the home directory for the given user\&. \fBParameters:\fP
.RS 4
\fIuid\fP the uid 
.br
\fIhomedir\fP string to append home directory to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if user existed and we appended their homedir 
.RE
.PP

.PP
Definition at line 447 of file dbus-userdb\&.c\&.
.PP
References _dbus_string_append(), _dbus_user_database_get_system(), _dbus_user_database_get_uid(), _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, DBusUserInfo::homedir, NULL, and TRUE\&.
.PP
Referenced by _dbus_append_keyring_directory_for_credentials()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_homedir_from_username\fP (const \fBDBusString\fP *username, \fBDBusString\fP *homedir)"
.PP
Gets the home directory for the given user\&. \fBParameters:\fP
.RS 4
\fIusername\fP the username 
.br
\fIhomedir\fP string to append home directory to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if user existed and we appended their homedir 
.RE
.PP

.PP
Definition at line 408 of file dbus-userdb\&.c\&.
.PP
References _dbus_string_append(), _dbus_user_database_get_system(), _dbus_user_database_get_username(), _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, DBusUserInfo::homedir, NULL, and TRUE\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_is_a_number\fP (const \fBDBusString\fP *str, unsigned long *num)"
.PP
Checks if a given string is actually a number and converts it if it is\&. \fBParameters:\fP
.RS 4
\fIstr\fP the string to check 
.br
\fInum\fP the memory location of the unsigned long to fill in 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE if str is a number and num is filled in 
.RE
.PP

.PP
Definition at line 103 of file dbus-userdb\&.c\&.
.PP
References _dbus_string_parse_uint(), FALSE, and TRUE\&.
.PP
Referenced by _dbus_user_database_lookup(), and _dbus_user_database_lookup_group()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_is_console_user\fP (\fBdbus_uid_t\fPuid, \fBDBusError\fP *error)"
.PP
Checks to see if the UID sent in is the console user\&. \fBParameters:\fP
.RS 4
\fIuid\fP UID of person to check 
.br
\fIerror\fP return location for errors 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if the UID is the same as the console user and there are no errors 
.RE
.PP

.PP
Definition at line 44 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_stat(), _dbus_string_append(), _dbus_string_free(), _dbus_string_init(), _dbus_user_at_console(), _dbus_user_database_get_system(), _dbus_user_database_lock_system(), _dbus_user_database_lookup(), _dbus_user_database_unlock_system(), DBUS_ERROR_FAILED, dbus_set_error(), FALSE, NULL, TRUE, DBusStat::uid, and DBusUserInfo::username\&.
.PP
Referenced by _dbus_unix_user_is_at_console()\&.
.SS "void* \fB_dbus_memdup\fP (const void *mem, size_tn_bytes)"
.PP
Duplicates a block of memory\&. Returns \fBNULL\fP on failure\&.
.PP
\fBParameters:\fP
.RS 4
\fImem\fP memory to copy 
.br
\fIn_bytes\fP number of bytes to copy 
.RE
.PP
\fBReturns:\fP
.RS 4
the copy 
.RE
.PP

.PP
Definition at line 508 of file dbus-internals\&.c\&.
.PP
References dbus_malloc(), and NULL\&.
.PP
Referenced by _dbus_credentials_add_adt_audit_data(), and _dbus_decompose_path()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_parse_unix_group_from_config\fP (const \fBDBusString\fP *groupname, \fBdbus_gid_t\fP *gid_p)"
.PP
Parse a UNIX group from the bus config file\&. On Windows, this should simply always fail (just return \fBFALSE\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIgroupname\fP the groupname text 
.br
\fIgid_p\fP place to return the gid 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP on success 
.RE
.PP

.PP
Definition at line 945 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_parse_unix_user_from_config\fP (const \fBDBusString\fP *username, \fBdbus_uid_t\fP *uid_p)"
.PP
Parse a UNIX user from the bus config file\&. On Windows, this should simply always fail (just return \fBFALSE\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIusername\fP the username text 
.br
\fIuid_p\fP place to return the uid 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP on success 
.RE
.PP

.PP
Definition at line 929 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_path_is_absolute\fP (const \fBDBusString\fP *filename)"
.PP
Checks whether the filename is an absolute path\&. \fBParameters:\fP
.RS 4
\fIfilename\fP the filename 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if an absolute path 
.RE
.PP

.PP
Definition at line 583 of file dbus-sysdeps-util-unix\&.c\&.
.PP
Referenced by _dbus_get_standard_session_servicedirs()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_read_uuid_file\fP (const \fBDBusString\fP *filename, \fBDBusGUID\fP *uuid, \fBdbus_bool_t\fPcreate_if_not_found, \fBDBusError\fP *error)"
.PP
Reads (and optionally writes) a uuid to a file\&. Initializes the uuid unless an error is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP the name of the file 
.br
\fIuuid\fP uuid to be initialized with the loaded uuid 
.br
\fIcreate_if_not_found\fP \fBTRUE\fP to create a new uuid and save it if the file doesn't exist 
.br
\fIerror\fP the error return 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if the error is set 
.RE
.PP

.PP
Definition at line 750 of file dbus-internals\&.c\&.
.PP
References dbus_error_free(), dbus_error_has_name(), DBUS_ERROR_INIT, DBUS_ERROR_INVALID_FILE_CONTENT, dbus_move_error(), FALSE, and TRUE\&.
.PP
Referenced by _dbus_read_local_machine_uuid(), and dbus_internal_do_not_use_get_uuid()\&.
.SS "void \fB_dbus_real_assert\fP (\fBdbus_bool_t\fPcondition, const char *condition_text, const char *file, intline, const char *func)"
.PP
Internals of _dbus_assert(); it's a function rather than a macro with the inline code so that the assertion failure blocks don't show up in test suite coverage, and to shrink code size\&. \fBParameters:\fP
.RS 4
\fIcondition\fP TRUE if assertion succeeded 
.br
\fIcondition_text\fP condition as a string 
.br
\fIfile\fP file the assertion is in 
.br
\fIline\fP line the assertion is in 
.br
\fIfunc\fP function the assertion is in 
.RE
.PP

.PP
Definition at line 889 of file dbus-internals\&.c\&.
.PP
References _dbus_abort(), _dbus_pid_for_log(), and _dbus_warn()\&.
.SS "void \fB_dbus_real_assert_not_reached\fP (const char *explanation, const char *file, intline)"
.PP
Internals of _dbus_assert_not_reached(); it's a function rather than a macro with the inline code so that the assertion failure blocks don't show up in test suite coverage, and to shrink code size\&. \fBParameters:\fP
.RS 4
\fIexplanation\fP what was reached that shouldn't have been 
.br
\fIfile\fP file the assertion is in 
.br
\fIline\fP line the assertion is in 
.RE
.PP

.PP
Definition at line 914 of file dbus-internals\&.c\&.
.PP
References _dbus_abort(), _dbus_pid_for_log(), and _dbus_warn()\&.
.SS "void \fB_dbus_request_file_descriptor_limit\fP (unsigned intlimit)"
.PP
Attempt to ensure that the current process can open at least  file descriptors\&. If  is lower than the current, it will not be lowered\&. No error is returned if the request can not be satisfied\&.
.PP
Number of file descriptors 
.PP
Definition at line 387 of file dbus-sysdeps-util-unix\&.c\&.
.SS "void \fB_dbus_set_signal_handler\fP (intsig, \fBDBusSignalHandler\fPhandler)"
.PP
Installs a UNIX signal handler\&. \fBParameters:\fP
.RS 4
\fIsig\fP the signal to handle 
.br
\fIhandler\fP the handler 
.RE
.PP

.PP
Definition at line 509 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_spawn_async_with_babysitter\fP (\fBDBusBabysitter\fP **sitter_p, char **argv, char **env, DBusSpawnChildSetupFuncchild_setup, void *user_data, \fBDBusError\fP *error)"
.PP
Spawns a new process\&. The executable name and argv[0] are the same, both are provided in argv[0]\&. The child_setup function is passed the given user_data and is run in the child just before calling exec()\&.
.PP
Also creates a 'babysitter' which tracks the status of the child process, advising the parent if the child exits\&. If the spawn fails, no babysitter is created\&. If sitter_p is \fBNULL\fP, no babysitter is kept\&.
.PP
\fBParameters:\fP
.RS 4
\fIsitter_p\fP return location for babysitter or \fBNULL\fP 
.br
\fIargv\fP the executable and arguments 
.br
\fIenv\fP the environment (not used on unix yet) 
.br
\fIchild_setup\fP function to call in child pre-exec() 
.br
\fIuser_data\fP user data for setup function 
.br
\fIerror\fP error object to be filled in if function fails 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP on success, \fBFALSE\fP if error is filled in 
.RE
.PP

.PP
Definition at line 1137 of file dbus-spawn\&.c\&.
.PP
References _dbus_babysitter_unref(), _dbus_full_duplex_pipe(), _dbus_strdup(), _dbus_watch_list_add_watch(), _dbus_watch_new(), DBUS_ERROR_NO_MEMORY, DBUS_ERROR_SPAWN_FORK_FAILED, dbus_free_string_array(), dbus_set_error(), dbus_set_error_const(), DBUS_WATCH_READABLE, DBusBabysitter::error_pipe_from_child, DBusBabysitter::error_watch, DBusBabysitter::executable, FALSE, NULL, READ_END, DBusBabysitter::sitter_pid, DBusBabysitter::sitter_watch, DBusBabysitter::socket_to_babysitter, TRUE, DBusBabysitter::watches, and WRITE_END\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_stat\fP (const \fBDBusString\fP *filename, \fBDBusStat\fP *statbuf, \fBDBusError\fP *error)"
.PP
stat() wrapper\&. \fBParameters:\fP
.RS 4
\fIfilename\fP the filename to stat 
.br
\fIstatbuf\fP the stat info to fill in 
.br
\fIerror\fP return location for error 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error was set 
.RE
.PP

.PP
Definition at line 600 of file dbus-sysdeps-util-unix\&.c\&.
.PP
Referenced by _dbus_is_console_user()\&.
.SS "char* \fB_dbus_strdup\fP (const char *str)"
.PP
Duplicates a string\&. Result must be freed with \fBdbus_free()\fP\&. Returns \fBNULL\fP if memory allocation fails\&. If the string to be duplicated is \fBNULL\fP, returns \fBNULL\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP string to duplicate\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
newly-allocated copy\&. 
.RE
.PP

.PP
Definition at line 480 of file dbus-internals\&.c\&.
.PP
References dbus_malloc(), and NULL\&.
.PP
Referenced by _dbus_credentials_add_windows_sid(), _dbus_dup_string_array(), _dbus_get_environment(), _dbus_message_iter_get_args_valist(), _dbus_server_new_for_domain_socket(), _dbus_spawn_async_with_babysitter(), _dbus_transport_get_windows_user(), _dbus_transport_open(), dbus_bus_get_id(), dbus_bus_register(), dbus_bus_set_unique_name(), dbus_connection_get_server_id(), dbus_server_get_address(), and dbus_set_error()\&.
.SS "const char* \fB_dbus_strerror_from_errno\fP (void)"
.PP
Get error message from errno\&. \fBReturns:\fP
.RS 4
_dbus_strerror(errno) 
.RE
.PP

.PP
Definition at line 1070 of file dbus-sysdeps\&.c\&.
.PP
Referenced by _dbus_close_socket(), _dbus_create_directory(), _dbus_delete_file(), _dbus_full_duplex_pipe(), _dbus_listen_tcp_socket(), _dbus_poll(), _dbus_send_credentials_socket(), _dbus_write_socket(), and _dbus_write_socket_two()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_string_array_contains\fP (const char **array, const char *str)"
.PP
Checks whether a string array contains the given string\&. \fBParameters:\fP
.RS 4
\fIarray\fP array to search\&. 
.br
\fIstr\fP string to look for 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if array contains string 
.RE
.PP

.PP
Definition at line 571 of file dbus-internals\&.c\&.
.PP
References FALSE, NULL, and TRUE\&.
.SS "void \fB_dbus_system_log\fP (DBusSystemLogSeverityseverity, const char *msg, \&.\&.\&.)"
.PP
Log a message to the system log file (e\&.g\&. syslog on Unix)\&.
.PP
\fBParameters:\fP
.RS 4
\fIseverity\fP a severity value 
.br
\fImsg\fP a printf-style format string 
.br
\fIargs\fP arguments for the format string 
.RE
.PP

.PP
Definition at line 444 of file dbus-sysdeps-util-unix\&.c\&.
.SS "void \fB_dbus_system_logv\fP (DBusSystemLogSeverityseverity, const char *msg, va_listargs)"
.PP
Log a message to the system log file (e\&.g\&. syslog on Unix)\&.
.PP
\fBParameters:\fP
.RS 4
\fIseverity\fP a severity value 
.br
\fImsg\fP a printf-style format string 
.br
\fIargs\fP arguments for the format string
.RE
.PP
If the FATAL severity is given, this function will terminate the program with an error code\&. 
.PP
Definition at line 466 of file dbus-sysdeps-util-unix\&.c\&.
.PP
Referenced by _dbus_system_log()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_unix_groups_from_uid\fP (\fBdbus_uid_t\fPuid, \fBdbus_gid_t\fP **group_ids, int *n_group_ids)"
.PP
Gets all groups corresponding to the given UNIX user ID\&. On UNIX, just calls \fB_dbus_groups_from_uid()\fP\&. On Windows, should always fail since we don't know any UNIX groups\&.
.PP
\fBParameters:\fP
.RS 4
\fIuid\fP the UID 
.br
\fIgroup_ids\fP return location for array of group IDs 
.br
\fIn_group_ids\fP return location for length of returned array 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if the UID existed and we got some credentials 
.RE
.PP

.PP
Definition at line 962 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_unix_user_is_at_console\fP (\fBdbus_uid_t\fPuid, \fBDBusError\fP *error)"
.PP
Checks to see if the UNIX user ID is at the console\&. Should always fail on Windows (set the error to \fBDBUS_ERROR_NOT_SUPPORTED\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIuid\fP UID of person to check 
.br
\fIerror\fP return location for errors 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if the UID is the same as the console user and there are no errors 
.RE
.PP

.PP
Definition at line 979 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_unix_user_is_process_owner\fP (\fBdbus_uid_t\fPuid)"
.PP
Checks to see if the UNIX user ID matches the UID of the process\&. Should always return \fBFALSE\fP on Windows\&.
.PP
\fBParameters:\fP
.RS 4
\fIuid\fP the UNIX user ID 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if this uid owns the process\&. 
.RE
.PP

.PP
Definition at line 994 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_user_at_console\fP (const char *username, \fBDBusError\fP *error)"
.PP
Checks if user is at the console\&. \fBParameters:\fP
.RS 4
\fIusername\fP user to check 
.br
\fIerror\fP return location for errors 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP is the user is at the consolei and there are no errors 
.RE
.PP

.PP
Definition at line 540 of file dbus-sysdeps-util-unix\&.c\&.
.PP
References _dbus_file_exists(), _dbus_string_append(), _dbus_string_free(), _dbus_string_init(), and FALSE\&.
.PP
Referenced by _dbus_is_console_user()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_user_database_get_gid\fP (DBusUserDatabase *db, \fBdbus_gid_t\fPgid, const \fBDBusGroupInfo\fP **info, \fBDBusError\fP *error)"
.PP
Gets the user information for the given GID, returned group info should not be freed\&. \fBParameters:\fP
.RS 4
\fIdb\fP user database 
.br
\fIgid\fP the group ID 
.br
\fIinfo\fP return location for const ref to group info 
.br
\fIerror\fP error location 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error is set 
.RE
.PP

.PP
Definition at line 334 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_user_database_lookup_group(), and NULL\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_user_database_get_groupname\fP (DBusUserDatabase *db, const \fBDBusString\fP *groupname, const \fBDBusGroupInfo\fP **info, \fBDBusError\fP *error)"
.PP
Gets the user information for the given group name, returned group info should not be freed\&. \fBParameters:\fP
.RS 4
\fIdb\fP user database 
.br
\fIgroupname\fP the group name 
.br
\fIinfo\fP return location for const ref to group info 
.br
\fIerror\fP error location 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error is set 
.RE
.PP

.PP
Definition at line 314 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_user_database_lookup_group(), DBUS_GID_UNSET, and NULL\&.
.PP
Referenced by _dbus_get_group_id()\&.
.SS "DBusUserDatabase* \fB_dbus_user_database_get_system\fP (void)"
.PP
Gets the system global user database; must be called with lock held (\fB_dbus_user_database_lock_system()\fP)\&. \fBReturns:\fP
.RS 4
the database or \fBNULL\fP if no memory 
.RE
.PP

.PP
Definition at line 333 of file dbus-userdb\&.c\&.
.PP
Referenced by _dbus_credentials_add_from_user(), _dbus_get_group_id(), _dbus_get_user_id_and_primary_group(), _dbus_groups_from_uid(), _dbus_homedir_from_uid(), _dbus_homedir_from_username(), and _dbus_is_console_user()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_user_database_get_uid\fP (DBusUserDatabase *db, \fBdbus_uid_t\fPuid, const \fBDBusUserInfo\fP **info, \fBDBusError\fP *error)"
.PP
Gets the user information for the given UID, returned user info should not be freed\&. \fBParameters:\fP
.RS 4
\fIdb\fP user database 
.br
\fIuid\fP the user ID 
.br
\fIinfo\fP return location for const ref to user info 
.br
\fIerror\fP error location 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error is set 
.RE
.PP

.PP
Definition at line 638 of file dbus-userdb\&.c\&.
.PP
References _dbus_user_database_lookup(), and NULL\&.
.PP
Referenced by _dbus_groups_from_uid(), and _dbus_homedir_from_uid()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_user_database_get_username\fP (DBusUserDatabase *db, const \fBDBusString\fP *username, const \fBDBusUserInfo\fP **info, \fBDBusError\fP *error)"
.PP
Gets the user information for the given username\&. \fBParameters:\fP
.RS 4
\fIdb\fP user database 
.br
\fIusername\fP the user name 
.br
\fIinfo\fP return location for const ref to user info 
.br
\fIerror\fP error location 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if error is set 
.RE
.PP

.PP
Definition at line 657 of file dbus-userdb\&.c\&.
.PP
References _dbus_user_database_lookup(), DBUS_UID_UNSET, and NULL\&.
.PP
Referenced by _dbus_credentials_add_from_user(), _dbus_get_user_id_and_primary_group(), and _dbus_homedir_from_username()\&.
.SS "\fBDBusUserInfo\fP* \fB_dbus_user_database_lookup\fP (DBusUserDatabase *db, \fBdbus_uid_t\fPuid, const \fBDBusString\fP *username, \fBDBusError\fP *error)"
.PP
Looks up a uid or username in the user database\&. Only one of name or UID can be provided\&. There are wrapper functions for this that are better to use, this one does no locking or anything on the database and otherwise sort of sucks\&.
.PP
\fBParameters:\fP
.RS 4
\fIdb\fP the database 
.br
\fIuid\fP the user ID or \fBDBUS_UID_UNSET\fP 
.br
\fIusername\fP username or \fBNULL\fP 
.br
\fIerror\fP error to fill in 
.RE
.PP
\fBReturns:\fP
.RS 4
the entry in the database 
.RE
.PP

.PP
Definition at line 128 of file dbus-userdb\&.c\&.
.PP
References _dbus_hash_table_insert_string(), _dbus_hash_table_insert_uintptr(), _dbus_hash_table_lookup_string(), _dbus_hash_table_lookup_uintptr(), _dbus_hash_table_remove_uintptr(), _dbus_is_a_number(), _dbus_user_info_fill(), _dbus_user_info_fill_uid(), _dbus_user_info_free_allocated(), DBUS_ERROR_NO_MEMORY, dbus_new0, dbus_set_error(), DBUS_UID_FORMAT, DBUS_UID_UNSET, NULL, DBusUserInfo::uid, and DBusUserInfo::username\&.
.PP
Referenced by _dbus_is_console_user(), _dbus_user_database_get_uid(), and _dbus_user_database_get_username()\&.
.SS "\fBDBusGroupInfo\fP* \fB_dbus_user_database_lookup_group\fP (DBusUserDatabase *db, \fBdbus_gid_t\fPgid, const \fBDBusString\fP *groupname, \fBDBusError\fP *error)"
.PP
Looks up a gid or group name in the user database\&. Only one of name or GID can be provided\&. There are wrapper functions for this that are better to use, this one does no locking or anything on the database and otherwise sort of sucks\&.
.PP
\fBParameters:\fP
.RS 4
\fIdb\fP the database 
.br
\fIgid\fP the group ID or \fBDBUS_GID_UNSET\fP 
.br
\fIgroupname\fP group name or \fBNULL\fP 
.br
\fIerror\fP error to fill in 
.RE
.PP
\fBReturns:\fP
.RS 4
the entry in the database 
.RE
.PP

.PP
Definition at line 209 of file dbus-userdb-util\&.c\&.
.PP
References _dbus_group_info_fill(), _dbus_group_info_fill_gid(), _dbus_group_info_free_allocated(), _dbus_hash_table_insert_string(), _dbus_hash_table_insert_uintptr(), _dbus_hash_table_lookup_string(), _dbus_hash_table_lookup_uintptr(), _dbus_hash_table_remove_uintptr(), _dbus_is_a_number(), DBUS_ERROR_NO_MEMORY, DBUS_GID_FORMAT, DBUS_GID_UNSET, dbus_new0, dbus_set_error(), DBUS_UID_UNSET, DBusGroupInfo::gid, DBusGroupInfo::groupname, and NULL\&.
.PP
Referenced by _dbus_user_database_get_gid(), and _dbus_user_database_get_groupname()\&.
.SS "DBusUserDatabase* \fB_dbus_user_database_new\fP (void)"
.PP
Creates a new user database object used to look up and cache user information\&. \fBReturns:\fP
.RS 4
new database, or \fBNULL\fP on out of memory 
.RE
.PP

.PP
Definition at line 531 of file dbus-userdb\&.c\&.
.PP
References _dbus_group_info_free_allocated(), _dbus_hash_table_new(), _dbus_user_database_unref(), _dbus_user_info_free_allocated(), DBUS_HASH_STRING, DBUS_HASH_UINTPTR, dbus_new0, and NULL\&.
.SS "void \fB_dbus_user_database_unref\fP (DBusUserDatabase *db)"
.PP
Decrements refcount of user database\&. \fBParameters:\fP
.RS 4
\fIdb\fP the database 
.RE
.PP

.PP
Definition at line 604 of file dbus-userdb\&.c\&.
.PP
References _dbus_hash_table_unref(), and dbus_free()\&.
.PP
Referenced by _dbus_user_database_new()\&.
.SS "void \fB_dbus_user_info_free\fP (\fBDBusUserInfo\fP *info)"
.PP
Frees the members of info (but not info itself) \fBParameters:\fP
.RS 4
\fIinfo\fP the user info struct 
.RE
.PP

.PP
Definition at line 76 of file dbus-userdb\&.c\&.
.PP
References dbus_free(), DBusUserInfo::group_ids, DBusUserInfo::homedir, and DBusUserInfo::username\&.
.PP
Referenced by _dbus_user_info_free_allocated()\&.
.SS "void \fB_dbus_user_info_free_allocated\fP (\fBDBusUserInfo\fP *info)"
.PP
Frees the given \fBDBusUserInfo\fP's members with \fB_dbus_user_info_free()\fP and also calls \fBdbus_free()\fP on the block itself\&. \fBParameters:\fP
.RS 4
\fIinfo\fP the info 
.RE
.PP

.PP
Definition at line 45 of file dbus-userdb\&.c\&.
.PP
References _dbus_user_info_free(), dbus_free(), and NULL\&.
.PP
Referenced by _dbus_user_database_lookup(), and _dbus_user_database_new()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_username_from_current_process\fP (const \fBDBusString\fP **username)"
.PP
Gets username of user owning current process\&. The returned string is valid until \fBdbus_shutdown()\fP is called\&.
.PP
\fBParameters:\fP
.RS 4
\fIusername\fP place to store pointer to username 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if no memory 
.RE
.PP

.PP
Definition at line 364 of file dbus-userdb\&.c\&.
.PP
References _dbus_user_database_lock_system(), _dbus_user_database_unlock_system(), FALSE, and TRUE\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_uuid_encode\fP (const \fBDBusGUID\fP *uuid, \fBDBusString\fP *encoded)"
.PP
Hex-encode a UUID\&. \fBParameters:\fP
.RS 4
\fIuuid\fP the uuid 
.br
\fIencoded\fP string to append hex uuid to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBFALSE\fP if no memory 
.RE
.PP

.PP
Definition at line 613 of file dbus-internals\&.c\&.
.PP
References _dbus_string_hex_encode(), and _dbus_string_init_const_len()\&.
.PP
Referenced by _dbus_get_local_machine_uuid_encoded(), and _dbus_server_init_base()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_verify_daemon_user\fP (const char *user)"
.PP
Verify that after the fork we can successfully change to this user\&. \fBParameters:\fP
.RS 4
\fIuser\fP the username given in the daemon configuration 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if username is valid 
.RE
.PP

.PP
Definition at line 304 of file dbus-sysdeps-util-unix\&.c\&.
.SS "void \fB_dbus_warn\fP (const char *format, \&.\&.\&.)"
.PP
Prints a warning message to stderr\&. Can optionally be made to exit fatally by setting DBUS_FATAL_WARNINGS, but this is rarely used\&. This function should be considered pretty much equivalent to fprintf(stderr)\&. \fB_dbus_warn_check_failed()\fP on the other hand is suitable for use when a programming mistake has been made\&.
.PP
\fBParameters:\fP
.RS 4
\fIformat\fP printf-style format string\&. 
.RE
.PP

.PP
Definition at line 244 of file dbus-internals\&.c\&.
.PP
References _dbus_abort()\&.
.PP
Referenced by _dbus_append_keyring_directory_for_credentials(), _dbus_babysitter_unref(), _dbus_change_to_daemon_user(), _dbus_full_duplex_pipe(), _dbus_get_tmpdir(), _dbus_listen_tcp_socket(), _dbus_listen_unix_socket(), _dbus_marshal_skip_basic(), _dbus_message_iter_get_args_valist(), _dbus_object_tree_unregister_and_unlock(), _dbus_poll(), _dbus_real_assert(), _dbus_real_assert_not_reached(), _dbus_server_new_for_launchd(), dbus_connection_register_fallback(), dbus_connection_register_object_path(), and dbus_message_append_args_valist()\&.
.SS "void \fB_dbus_warn_check_failed\fP (const char *format, \&.\&.\&.)"
.PP
Prints a 'critical' warning to stderr when an assertion fails; differs from _dbus_warn primarily in that it prefixes the pid and defaults to fatal\&. This should be used only when a programming error has been detected\&. (NOT for unavoidable errors that an app might handle - those should be returned as \fBDBusError\fP\&.) Calling this means 'there is a bug' 
.PP
Definition at line 272 of file dbus-internals\&.c\&.
.PP
References _dbus_abort(), and _dbus_pid_for_log()\&.
.PP
Referenced by _dbus_data_slot_allocator_alloc(), _dbus_get_local_machine_uuid_encoded(), _dbus_marshal_read_basic(), _dbus_transport_handle_watch(), _dbus_type_reader_recurse(), dbus_connection_close(), dbus_connection_remove_filter(), dbus_connection_unref(), dbus_server_ref(), dbus_server_set_timeout_functions(), dbus_server_set_watch_functions(), dbus_server_unref(), and dbus_watch_handle()\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_windows_user_is_process_owner\fP (const char *windows_sid)"
.PP
Checks to see if the Windows user SID matches the owner of the process\&. Should always return \fBFALSE\fP on UNIX\&.
.PP
\fBParameters:\fP
.RS 4
\fIwindows_sid\fP the Windows user SID 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBTRUE\fP if this user owns the process\&. 
.RE
.PP

.PP
Definition at line 1007 of file dbus-sysdeps-util-unix\&.c\&.
.SS "\fBdbus_bool_t\fP \fB_dbus_write_pid_to_file_and_pipe\fP (const \fBDBusString\fP *pidfile, \fBDBusPipe\fP *print_pid_pipe, \fBdbus_pid_t\fPpid_to_write, \fBDBusError\fP *error)"
.PP
Writes the given pid_to_write to a pidfile (if non-NULL) and/or to a pipe (if non-NULL)\&. Does nothing if pidfile and print_pid_pipe are both NULL\&.
.PP
\fBParameters:\fP
.RS 4
\fIpidfile\fP the file to write to or \fBNULL\fP 
.br
\fIprint_pid_pipe\fP the pipe to write to or \fBNULL\fP 
.br
\fIpid_to_write\fP the pid to write out 
.br
\fIerror\fP error on failure 
.RE
.PP
\fBReturns:\fP
.RS 4
FALSE if error is set 
.RE
.PP

.PP
Definition at line 230 of file dbus-sysdeps-util-unix\&.c\&.
.PP
Referenced by _dbus_become_daemon()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for D-Bus from the source code\&.
